// ================================================
//  Unified notification system, written by Samual
//  Last updated: February, 2013
// ================================================

entity Get_Notif_Ent(float net_type, float net_name)
{
	switch(net_type)
	{
		case MSG_INFO: return msg_info_notifs[net_name - 1];
		case MSG_CENTER: return msg_center_notifs[net_name - 1];
		case MSG_WEAPON: return msg_weapon_notifs[net_name - 1];
		case MSG_DEATH: return msg_death_notifs[net_name - 1];
	}
	backtrace(sprintf("Get_Notif_Ent(%d, %d): Improper net type!\n", net_type, net_name));
	return world;
}


// ===============================
//  Frontend Notification Pushing
// ===============================

void Dump_Notifications(float fh, float alsoprint)
{
	#define NOTIF_WRITE(a) { \
		fputs(fh, a); \
		if(alsoprint) { print(a); } }
	#define NOTIF_WRITE_SETA(name,default,text) { \
		notif_msg = \
			sprintf( \
				"seta notification_%s %d \"notif string: %s^7\"\n", \
				name, default, strreplace("\{3}", "", strreplace("\n", "\\n", text)) \
			); \
		NOTIF_WRITE(notif_msg) }

	string notif_msg;
	float i;
	entity e;

	// Note: This warning only applies to the notifications.cfg file that is output...

	// You ARE supposed to manually edit this function to add i.e. hard coded
	// notification variables for mutators or game modes or such and then
	// regenerate the notifications.cfg file from the new code.

	NOTIF_WRITE("// ********************************************** //\n");
	NOTIF_WRITE("// ** WARNING - DO NOT MANUALLY EDIT THIS FILE ** //\n");
	NOTIF_WRITE("// **                                          ** //\n");
	NOTIF_WRITE("// **  This file is automatically generated    ** //\n");
	NOTIF_WRITE("// **  by code with the command 'dumpnotifs'.  ** //\n");
	NOTIF_WRITE("// **                                          ** //\n");
	NOTIF_WRITE("// **  If you add a new notification, please   ** //\n");
	NOTIF_WRITE("// **  regenerate this file with that command  ** //\n");
	NOTIF_WRITE("// **  making sure that the output matches     ** //\n");
	NOTIF_WRITE("// **  with the lists and defaults in code.    ** //\n");
	NOTIF_WRITE("// **                                          ** //\n");
	NOTIF_WRITE("// ********************************************** //\n");

	// These notifications will also append their string as a comment...
	// This is not necessary, and does not matter if they vary between config versions,
	// it is just a semi-helpful tool for those who want to manually change their user settings.

	NOTIF_WRITE(sprintf("\n// MSG_INFO notifications (count = %d):\n", NOTIF_INFO_COUNT));
	for(i = 1; i <= NOTIF_INFO_COUNT; ++i)
	{
		e = Get_Notif_Ent(MSG_INFO, i);
		if not(e) { backtrace("Dump_Notifications(): Missing notification entity!\n"); return; }
		NOTIF_WRITE_SETA(e.nent_name, e.nent_default, e.nent_string);
	}

	NOTIF_WRITE(sprintf("\n// MSG_CENTER notifications (count = %d):\n", NOTIF_CENTER_COUNT));
	for(i = 1; i <= NOTIF_CENTER_COUNT; ++i)
	{
		e = Get_Notif_Ent(MSG_CENTER, i);
		if not(e) { backtrace("Dump_Notifications(): Missing notification entity!\n"); return; }
		NOTIF_WRITE_SETA(e.nent_name, e.nent_default, e.nent_string);
	}

	NOTIF_WRITE(sprintf("\n// MSG_WEAPON notifications (count = %d):\n", NOTIF_WEAPON_COUNT));
	for(i = 1; i <= NOTIF_WEAPON_COUNT; ++i)
	{
		e = Get_Notif_Ent(MSG_WEAPON, i);
		if not(e) { backtrace("Dump_Notifications(): Missing notification entity!\n"); return; }
		NOTIF_WRITE_SETA(e.nent_name, e.nent_default, sprintf("infoname: %s, centername: %s",
			e.nent_msginfo.nent_name, e.nent_msgcenter.nent_name));
	}

	NOTIF_WRITE(sprintf("\n// MSG_DEATH notifications (count = %d):\n", NOTIF_DEATH_COUNT));
	for(i = 1; i <= NOTIF_DEATH_COUNT; ++i)
	{
		e = Get_Notif_Ent(MSG_DEATH, i);
		if not(e) { backtrace("Dump_Notifications(): Missing notification entity!\n"); return; }
		NOTIF_WRITE_SETA(e.nent_name, e.nent_default, sprintf("infoname: %s, centername: %s",
			e.nent_msginfo.nent_name, e.nent_msgcenter.nent_name));
	}

	// edit these to match whichever cvars are used for specific notification options
	NOTIF_WRITE("\n// HARD CODED notification variables:\n");
	NOTIF_WRITE("seta notification_allow_chatboxprint 1 \"Allow notifications to be printed to chat box by setting notification cvar to 2 (You can also set this cvar to 2 to force ALL notifications to be printed to the chatbox)\"\n");
	NOTIF_WRITE("seta notification_show_location 0 \"Append location information to MSG_INFO death/kill messages\"\n");
	NOTIF_WRITE("seta notification_show_location_string \"\" \"Replacement string piped into sprintf, so you can do different messages like this: ' at the %s' or ' (near %s)'\"\n");
	NOTIF_WRITE("seta notification_show_sprees 1 \"Print information about sprees in death/kill messages\"\n");
	NOTIF_WRITE("seta notification_show_sprees_center 1 \"Show spree information in MSG_CENTER messages... 0 = off, 1 = target (but only for first victim) and attacker\"\n");
	NOTIF_WRITE("seta notification_show_sprees_center_specialonly 1 \"Don't show spree information in MSG_CENTER messages if it isn't an achievement\"\n");
	NOTIF_WRITE("seta notification_show_sprees_info 3 \"Show spree information in MSG_INFO messages... 0 = off, 1 = target only, 2 = attacker only, 3 = target and attacker\"\n");
	NOTIF_WRITE("seta notification_show_sprees_info_newline 0 \"Show attacker spree information for MSG_INFO messages on a separate line than the death notification itself\"\n");
	NOTIF_WRITE("seta notification_show_sprees_info_specialonly 1 \"Don't show attacker spree information in MSG_INFO messages if it isn't an achievement\"\n");
	NOTIF_WRITE("seta notification_errors_are_fatal 1 \"If a notification fails upon initialization, cause a Host_Error to stop the program\"\n");
	NOTIF_WRITE("seta notification_ctf_pickup_team_verbose 1 \"Show extra information if a team mate picks up a flag\"\n");
	NOTIF_WRITE("seta notification_ctf_pickup_enemy_verbose 1 \"Show extra information if an enemy picks up a flag\"\n");
	NOTIF_WRITE("seta notification_ctf_capture_verbose 1 \"Show extra information when someone captures a flag\"\n");
	NOTIF_WRITE("seta notification_frag_verbose 1 \"Show extra information when you frag someone (or when you are fragged\"\n");

	NOTIF_WRITE(sprintf("\n// Notification counts (total = %d): MSG_INFO = %d, MSG_CENTER = %d, MSG_WEAPON = %d, MSG_DEATH = %d\n",
		(NOTIF_INFO_COUNT + NOTIF_CENTER_COUNT + NOTIF_WEAPON_COUNT + NOTIF_DEATH_COUNT), 
		NOTIF_INFO_COUNT, NOTIF_CENTER_COUNT, NOTIF_WEAPON_COUNT, NOTIF_DEATH_COUNT));
	
	return;
	#undef NOTIF_WRITE_SETA
	#undef NOTIF_WRITE
}

#ifdef SVQC
void Notification_GetCvars()
{
	GetCvars_handleFloat(get_cvars_s, get_cvars_f, FRAG_VERBOSE, "notification_frag_verbose");
}
#endif

string Local_Notification_sprintf(string input, string args, 
	string s1, string s2, string s3, string s4,
	float f1, float f2, float f3, float f4)
{
	#ifdef NOTIFICATIONS_DEBUG
	dprint(
		sprintf("Local_Notification_sprintf('%s^7', '%s', %s, %s);\n",
			strreplace("\n", "\\n", input),
			args,
			sprintf("'%s^7', '%s^7', '%s^7', '%s^7'", s1, s2, s3, s4),
			sprintf("%d, %d, %d, %d", f1, f2, f3, f4)
		)
	);
	#endif
	
	string selected;
	float sel_num;
	for(sel_num = 0; sel_num < NOTIF_MAX_ARGS; ++sel_num) { arg_slot[sel_num] = ""; }

	string tmp_s;

	for(sel_num = 0;(args != "");)
	{
		selected = car(args); args = cdr(args);
		NOTIF_HIT_MAX(NOTIF_MAX_ARGS, "Local_Notification_sprintf")
		switch(strtolower(selected))
		{
			#define ARG_CASE(prog,selected,result) \
				#ifdef CSQC \
					#if (prog != ARG_SV) \
						case selected: { arg_slot[sel_num] = result; ++sel_num; break; } \
					#endif \
				#else \
					#if (prog != ARG_CS) \
						case selected: { arg_slot[sel_num] = result; ++sel_num; break; } \
					#endif \
				#endif
			NOTIF_ARGUMENT_LIST
			#undef ARG_CASE
			default: NOTIF_HIT_UNKNOWN(NOTIF_MAX_ARGS, "Local_Notification_sprintf")
		}
	}
	return sprintf(input, arg_slot[0], arg_slot[1], arg_slot[2], arg_slot[3], arg_slot[4], arg_slot[5], arg_slot[6]);
}

#ifdef CSQC
void Local_Notification_HUD_Notify_Push(string icon, string hudargs, string s1, string s2, string s3, string s4)
{
	string selected;
	float sel_num;
	arg_slot[0] = ""; arg_slot[1] = "";

	for(sel_num = 0;(hudargs != "");)
	{
		selected = car(hudargs); hudargs = cdr(hudargs);
		NOTIF_HIT_MAX(NOTIF_MAX_HUDARGS, "Local_Notification_HUD_Notify_Push")
		switch(strtolower(selected))
		{
			#define ARG_CASE(prog,selected,result) \
				#if (prog == ARG_CS_SV_HA) \
					case selected: { arg_slot[sel_num] = result; ++sel_num; break; } \
				#endif
			NOTIF_ARGUMENT_LIST
			#undef ARG_CASE
			default: NOTIF_HIT_UNKNOWN(NOTIF_MAX_HUDARGS, "Local_Notification_HUD_Notify_Push")
		}
	}
	HUD_Notify_Push(icon, arg_slot[0], arg_slot[1]);
}

void Local_Notification_centerprint_generic(string input, string durcnt, float cpid, float f1, float f2)
{
	string selected;
	float sel_num;
	arg_slot[0] = ""; arg_slot[1] = "";

	for(sel_num = 0;(durcnt != "");)
	{
		selected = car(durcnt); durcnt = cdr(durcnt);
		NOTIF_HIT_MAX(NOTIF_MAX_DURCNT, "Local_Notification_centerprint_generic")
		switch(strtolower(selected))
		{
			#define ARG_CASE(prog,selected,result) \
				#if (prog == ARG_CS_SV_DC) \
					case selected: { arg_slot[sel_num] = result; ++sel_num; break; } \
				#endif
			NOTIF_ARGUMENT_LIST
			#undef ARG_CASE
			default:
			{
				if(ftos(stof(selected)) != "") { arg_slot[sel_num] = selected; ++sel_num; }
				else { NOTIF_HIT_UNKNOWN(NOTIF_MAX_DURCNT, "Local_Notification_centerprint_generic") }
				break;
			}
		}
	}
	centerprint_generic(cpid, input, stof(arg_slot[0]), stof(arg_slot[1]));
}
#endif

void Local_Notification(float net_type, float net_name, ...count)
{
	// check supplied type and name for errors
	string checkargs = "";
	#define CHECKARG_TYPENAME(type) case MSG_##type##: \
		{ if(!net_name || (net_name > NOTIF_##type##_COUNT)) \
		{ checkargs = sprintf("Improper name: %d!", net_name); } break; }
	switch(net_type)
	{
		CHECKARG_TYPENAME(INFO)
		CHECKARG_TYPENAME(CENTER)
		CHECKARG_TYPENAME(WEAPON)
		CHECKARG_TYPENAME(DEATH)
		default: { checkargs = sprintf("Improper type: %d!", checkargs, net_type); break; }
	}
	#undef CHECKARG_TYPENAME
	if(checkargs != "") { backtrace(sprintf("Incorrect usage of Local_Notification: %s\n", checkargs)); return; }

	entity notif = Get_Notif_Ent(net_type, net_name);
	if not(notif) { backtrace("Local_Notification: Could not find notification entity!\n"); return; }
	if not(notif.nent_enabled) { print("Local_Notification: Entity was disabled...\n"); return; }

	if((notif.nent_stringcount + notif.nent_floatcount) > count)
	{
		backtrace(sprintf(
			strcat(
				"Not enough arguments for Local_Notification(%d, %s, ...)! ",
				"stringcount(%d) + floatcount(%d) > count(%d)\n", 
				"Check the definition and function call for accuracy...?\n"
			),
			net_type, notif.nent_name, notif.nent_stringcount, notif.nent_floatcount, count));
		return;
	}
	else if((notif.nent_stringcount + notif.nent_floatcount) < count)
	{
		backtrace(sprintf(
			strcat(
				"Too many arguments for Local_Notification(%d, %s, ...)! ",
				"stringcount(%d) + floatcount(%d) < count(%d)\n",
				"Check the definition and function call for accuracy...?\n"
			),
			net_type, notif.nent_name, notif.nent_stringcount, notif.nent_floatcount, count));
		return;
	}

	string s1 = ((0 < notif.nent_stringcount) ? ...(0, string) : "");
	string s2 = ((1 < notif.nent_stringcount) ? ...(1, string) : "");
	string s3 = ((2 < notif.nent_stringcount) ? ...(2, string) : "");
	string s4 = ((3 < notif.nent_stringcount) ? ...(3, string) : "");
	float f1 = ((0 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 0), float) : 0);
	float f2 = ((1 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 1), float) : 0);
	float f3 = ((2 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 2), float) : 0);
	float f4 = ((3 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 3), float) : 0);

	#ifdef NOTIFICATIONS_DEBUG
	dprint(
		sprintf("Local_Notification(%d, %s, %s, %s);\n",
			net_type,
			notif.nent_name,
			sprintf("'%s^7', '%s^7', '%s^7', '%s^7'", s1, s2, s3, s4),
			sprintf("%d, %d, %d, %d", f1, f2, f3, f4)
		)
	);
	#endif
	
	switch(net_type)
	{
		case MSG_INFO:
		{
			print(
				Local_Notification_sprintf(
					notif.nent_string,
					notif.nent_args, 
					s1, s2, s3, s4,
					f1, f2, f3, f4)
			);
			#ifdef CSQC 
			if(notif.nent_icon != "")
			{
				Local_Notification_HUD_Notify_Push(
					notif.nent_icon,
					notif.nent_hudargs,
					s1, s2, s3, s4);
			} 
			#endif 
			break;
		}
		
		#ifdef CSQC
		case MSG_CENTER:
		{
			Local_Notification_centerprint_generic(
				Local_Notification_sprintf(
					notif.nent_string,
					notif.nent_args, 
					s1, s2, s3, s4,
					f1, f2, f3, f4),
				notif.nent_durcnt,
				notif.nent_cpid,
				f1, f2);
			break;
		}
		#endif
		
		case MSG_WEAPON:
		case MSG_DEATH:
		{
			if(notif.nent_msginfo)
			if(notif.nent_msginfo.nent_enabled)
			{
				Local_Notification_WOVA(
					MSG_INFO,
					notif.nent_msginfo.nent_id, 
					notif.nent_msginfo.nent_stringcount, 
					notif.nent_msginfo.nent_floatcount, 
					s1, s2, s3, s4,
					f1, f2, f3, f4);
			}
			#ifdef CSQC
			if(notif.nent_msgcenter)
			if(notif.nent_msgcenter.nent_enabled)
			{
				Local_Notification_WOVA(
					MSG_CENTER,
					notif.nent_msgcenter.nent_id, 
					notif.nent_msgcenter.nent_stringcount, 
					notif.nent_msgcenter.nent_floatcount, 
					s1, s2, s3, s4,
					f1, f2, f3, f4); 
			}
			#endif
			break;
		}
	}
}

// WOVA = Without Variable Arguments 
void Local_Notification_WOVA(float net_type, float net_name,
	float stringcount, float floatcount,
	string s1, string s2, string s3, string s4,
	float f1, float f2, float f3, float f4)
{
	#define VARITEM(stringc,floatc,args) \
		if((stringcount == stringc) && (floatcount == floatc)) \
			{ Local_Notification(net_type, net_name, args); return; }
	EIGHT_VARS_TO_VARARGS_VARLIST
	#undef VARITEM
	Local_Notification(net_type, net_name); // some notifications don't have any arguments at all
}


// =========================
//  Notification Networking
// =========================

#ifdef CSQC
void Read_Notification(float is_new)
{
	float net_type = ReadByte();
	float net_name = ReadShort();

	entity notif = Get_Notif_Ent(net_type, net_name);
	if not(notif) { print("Read_Notification: Could not find notification entity!\n"); return; }

	string s1 = ((0 < notif.nent_stringcount) ? ReadString() : "");
	string s2 = ((1 < notif.nent_stringcount) ? ReadString() : "");
	string s3 = ((2 < notif.nent_stringcount) ? ReadString() : "");
	string s4 = ((3 < notif.nent_stringcount) ? ReadString() : "");
	float f1 = ((0 < notif.nent_floatcount) ? ReadLong() : 0);
	float f2 = ((1 < notif.nent_floatcount) ? ReadLong() : 0);
	float f3 = ((2 < notif.nent_floatcount) ? ReadLong() : 0);
	float f4 = ((3 < notif.nent_floatcount) ? ReadLong() : 0);

	#ifdef NOTIFICATIONS_DEBUG
	dprint(sprintf("Read_Notification(%d) at %f: net_name = %s.\n", is_new, time, notif.nent_name));
	#endif
	
	if(is_new)
	{
		Local_Notification_WOVA(
			net_type, net_name,
			notif.nent_stringcount,
			notif.nent_floatcount,
			s1, s2, s3, s4,
			f1, f2, f3, f4);
	}
}
#endif

#ifdef SVQC
void Net_Notification_Remove()
{
	float i;
	for(i = 0; i < 4; ++i) { if(self.nent_strings[i]) { strunzone(self.nent_strings[i]); } }
	remove(self);
}

float Net_Write_Notification(entity client, float sf)
{
	float i, send = FALSE;
	
	switch(self.nent_broadcast)
	{
		case NOTIF_ONE: // send to one client and their spectator
		{
			if(
				(client == self.nent_client)
				||
				(
					(client.classname == STR_SPECTATOR)
					&&
					(client.enemy == self.nent_client)
				)
			) { send = TRUE; }
			break;
		}
		case NOTIF_ONE_ONLY: // send ONLY to one client
		{
			if(client == self.nent_client) { send = TRUE; }
			break;
		}
		case NOTIF_TEAM: // send only to X team and their spectators
		{
			if(
				(client.team == self.nent_client.team)
				||
				(
					(client.classname == STR_SPECTATOR)
					&&
					(client.enemy.team == self.nent_client.team)
				)
			) { send = TRUE; }
			break;
		}
		case NOTIF_TEAM_EXCEPT: // send only to X team and their spectators, except for Y person and their spectators
		{
			if(
				(client != self.nent_client)
				&&
				(
					(client.team == self.nent_client.team)
					||
					(
						(client.classname == STR_SPECTATOR)
						&&
						(
							(client.enemy != self.nent_client)
							&&
							(client.enemy.team == self.nent_client.team)
						)
					)
				)
			) { send = TRUE; }
			break;
		}
		case NOTIF_ANY: // send to everyone
		{
			send = TRUE;
			break;
		}
		case NOTIF_ANY_EXCEPT: // send to everyone except X person and their spectators
		{
			if(
				(client != self.nent_client)
				&&
				!(
					(client.classname == STR_SPECTATOR)
					&&
					(client.enemy == self.nent_client)
				)
			) { send = TRUE; }
			break;
		}
		default: { send = FALSE; break; }
	}

	if(send)
	{		
		WriteByte(MSG_ENTITY, ENT_CLIENT_NOTIFICATION);
		WriteByte(MSG_ENTITY, self.nent_net_type);
		WriteShort(MSG_ENTITY, self.nent_net_name);
		for(i = 0; i < self.nent_stringcount; ++i) { WriteString(MSG_ENTITY, self.nent_strings[i]); } 
		for(i = 0; i < self.nent_floatcount; ++i) { WriteLong(MSG_ENTITY, self.nent_floats[i]); }
	}

	return send; 
}

void Send_Notification(float broadcast, entity client,
	float net_type, float net_name, ...count)
{
	// check supplied broadcast, target, type, and name for errors
	string checkargs = "";
	#define CHECKARG_TYPENAME(type) case MSG_##type##: \
		{ if(!net_name || (net_name > NOTIF_##type##_COUNT)) \
		{ checkargs = sprintf("Improper name: %d!", net_name); } break; }
	switch(net_type)
	{
		CHECKARG_TYPENAME(INFO)
		CHECKARG_TYPENAME(CENTER)
		CHECKARG_TYPENAME(WEAPON)
		CHECKARG_TYPENAME(DEATH)
		default: { checkargs = sprintf("Improper type: %d!", checkargs, net_type); break; }
	}
	#undef CHECKARG_TYPENAME
	if(checkargs != "") { checkargs = strcat(checkargs, " "); }
	switch(broadcast)
	{
		case NOTIF_ONE:
		case NOTIF_ONE_ONLY:
		{
			if(IS_NOT_A_CLIENT(client))
				{ checkargs = sprintf("%sNo client provided!", checkargs); }
			break;
		}
		
		case NOTIF_ANY_EXCEPT:
		{
			if(IS_NOT_A_CLIENT(client))
				{ checkargs = sprintf("%sException can't be a non-client!", checkargs); }
			break;
		}
		
		case NOTIF_ANY:
		{
			if(client)
				{ checkargs = sprintf("%sEntity provided when world was required!", checkargs); }
			break;
		}
		
		case NOTIF_TEAM:
		case NOTIF_TEAM_EXCEPT:
		{
			if not(teamplay) { checkargs = sprintf("%sTeamplay not active!", checkargs); }
			else if(IS_NOT_A_CLIENT(client))
			{
				if(broadcast == NOTIF_TEAM) { checkargs = sprintf("%sNo client provided!", checkargs); }
				else { checkargs = sprintf("%sException can't be a non-client!", checkargs); }
			}
			break;
		}
		
		default: { checkargs = sprintf("%sImproper broadcast: %d!", checkargs, broadcast); break; }
	}
	if(checkargs != "") { backtrace(sprintf("Incorrect usage of Send_Notification: %s\n", checkargs)); return; }

	// retreive counts for the arguments of this notification
	entity notif = Get_Notif_Ent(net_type, net_name);
	if not(notif) { backtrace("Send_Notification: Could not find notification entity!\n"); return; }

	if((notif.nent_stringcount + notif.nent_floatcount) > count)
	{
		backtrace(sprintf(
			strcat(
				"Not enough arguments for Send_Notification(%d, %d, %s, ...)! ",
				"stringcount(%d) + floatcount(%d) > count(%d)\n", 
				"Check the definition and function call for accuracy...?\n"
			),
			broadcast, net_type, notif.nent_name, notif.nent_stringcount, notif.nent_floatcount, count));
		return;
	}
	else if((notif.nent_stringcount + notif.nent_floatcount) < count)
	{
		backtrace(sprintf(
			strcat(
				"Too many arguments for Send_Notification(%d, %d, %s, ...)! ",
				"stringcount(%d) + floatcount(%d) < count(%d)\n",
				"Check the definition and function call for accuracy...?\n"
			),
			broadcast, net_type, notif.nent_name, notif.nent_stringcount, notif.nent_floatcount, count));
		return;
	}

	#ifdef NOTIFICATIONS_DEBUG
	string s1 = ((0 < notif.nent_stringcount) ? ...(0, string) : "");
	string s2 = ((1 < notif.nent_stringcount) ? ...(1, string) : "");
	string s3 = ((2 < notif.nent_stringcount) ? ...(2, string) : "");
	string s4 = ((3 < notif.nent_stringcount) ? ...(3, string) : "");
	float f1 = ((0 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 0), float) : 0);
	float f2 = ((1 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 1), float) : 0);
	float f3 = ((2 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 2), float) : 0);
	float f4 = ((3 < notif.nent_floatcount) ? ...((notif.nent_stringcount + 3), float) : 0);
	dprint(
		sprintf("Send_Notification(%d, %d, %s, %s, %s - %d %d);\n",
			broadcast,
			net_type,
			notif.nent_name,
			sprintf("'%s^7', '%s^7', '%s^7', '%s^7'", s1, s2, s3, s4),
			sprintf("%d, %d, %d, %d", f1, f2, f3, f4),
			notif.nent_stringcount, notif.nent_floatcount
		)
	);
	#endif

	entity net_notif = spawn();
	net_notif.nent_broadcast = broadcast;
	net_notif.nent_client = client;
	net_notif.nent_net_type = net_type;
	net_notif.nent_net_name = net_name;
	net_notif.nent_stringcount = notif.nent_stringcount;
	net_notif.nent_floatcount = notif.nent_floatcount;
	
	float i;
	for(i = 0; i < net_notif.nent_stringcount; ++i) { net_notif.nent_strings[i] = strzone(...(i, string)); }
	for(i = 0; i < net_notif.nent_floatcount; ++i) { net_notif.nent_floats[i] = ...((net_notif.nent_stringcount + i), float); }
	
	net_notif.think = Net_Notification_Remove;
	net_notif.nextthink = (time + 0.5); 

	Net_LinkEntity(net_notif, FALSE, 0, Net_Write_Notification);

	if((!server_is_local) && (broadcast == NOTIF_ANY || broadcast == NOTIF_ANY_EXCEPT) && (net_type != MSG_CENTER))
	{
		Local_Notification_WOVA(
			net_type, net_name,
			notif.nent_stringcount,
			notif.nent_floatcount,
			IFSTR(0), IFSTR(1), IFSTR(2), IFSTR(3),
			IFFL(0), IFFL(1), IFFL(2), IFFL(3));
	}
}

// WOVA = Without Variable Arguments 
void Send_Notification_WOVA(float broadcast, entity client,
	float net_type, float net_name,
	string s1, string s2, string s3, string s4,
	float f1, float f2, float f3, float f4)
{
	entity notif = Get_Notif_Ent(net_type, net_name);
	
	#ifdef NOTIFICATIONS_DEBUG
	dprint(
		sprintf("Send_Notification_WOVA(%d, %d, %s, %s, %s - %d %d);\n",
			broadcast,
			net_type,
			notif.nent_name,
			sprintf("'%s^7', '%s^7', '%s^7', '%s^7'", s1, s2, s3, s4),
			sprintf("%d, %d, %d, %d", f1, f2, f3, f4),
			notif.nent_stringcount, notif.nent_floatcount
		)
	);
	#endif
	
	#define VARITEM(stringc,floatc,args) \
		if((notif.nent_stringcount == stringc) && (notif.nent_floatcount == floatc)) \
			{ Send_Notification(broadcast, client, net_type, net_name, args); return; }
	EIGHT_VARS_TO_VARARGS_VARLIST
	#undef VARITEM
	Send_Notification(broadcast, client, net_type, net_name); // some notifications don't have any arguments at all
}


// =============================
//  LEGACY NOTIFICATION SYSTEMS
// =============================

void Send_CSQC_Centerprint_Generic(entity e, float id, string s, float duration, float countdown_num)
{
	if ((clienttype(e) == CLIENTTYPE_REAL) && (e.flags & FL_CLIENT))
	{
		msg_entity = e;
		WRITESPECTATABLE_MSG_ONE({
			WriteByte(MSG_ONE, SVC_TEMPENTITY);
			WriteByte(MSG_ONE, TE_CSQC_CENTERPRINT_GENERIC);
			WriteByte(MSG_ONE, id);
			WriteString(MSG_ONE, s);
			if (id != 0 && s != "")
			{
				WriteByte(MSG_ONE, duration);
				WriteByte(MSG_ONE, countdown_num);
			}
		});
	}
}
#endif // ifdef SVQC
