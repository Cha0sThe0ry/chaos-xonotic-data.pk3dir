#ifndef WEAPONS_ALL_H
#define WEAPONS_ALL_H

// weapon sets
typedef vector WepSet;
#define WEPSET(id) WepSet_FromWeapon(WEP_##id.m_id)
WepSet WepSet_FromWeapon(int a);
#ifdef SVQC
void WepSet_AddStat();
void WepSet_AddStat_InMap();
void WriteWepSet(float dest, WepSet w);
#endif

#ifdef CSQC
WepSet WepSet_GetFromStat();
WepSet WepSet_GetFromStat_InMap();
WepSet ReadWepSet();
#endif

#include "weapon.qh"

#ifndef MENUQC
#include "calculations.qh"
#include "../models/models.qh"
#endif

#include "../util.qh"

#ifdef SVQC
#include "../../server/bot/aim.qh"
#endif

REGISTRY(Weapons, 72) // Increase as needed. Can be up to 72.
REGISTER_REGISTRY(RegisterWeapons)
entity get_weaponinfo(int id);

#define REGISTER_WEAPON(id, inst) \
	/* WepSet WEPSET_##id; */ \
	REGISTER(RegisterWeapons, WEP, Weapons, Weapons_COUNT, id, m_id, inst)

// create cvars for weapon settings
#define WEP_ADD_CVAR_NONE(wepname,name) [[last]] float autocvar_g_balance_##wepname##_##name;

#define WEP_ADD_CVAR_PRI(wepname,name) WEP_ADD_CVAR_NONE(wepname, primary_##name)
#define WEP_ADD_CVAR_SEC(wepname,name) WEP_ADD_CVAR_NONE(wepname, secondary_##name)
#define WEP_ADD_CVAR_BOTH(wepname,name) \
	WEP_ADD_CVAR_PRI(wepname, name) \
	WEP_ADD_CVAR_SEC(wepname, name)

#define WEP_ADD_CVAR(wepid,wepname,mode,name) WEP_ADD_CVAR_##mode(wepname, name)

// create properties for weapon settings
#define WEP_ADD_PROP(wepid,wepname,type,prop,name) \
	.type prop; \
	[[last]] type autocvar_g_balance_##wepname##_##name;

// read cvars from weapon settings
#define WEP_CVAR(wepname,name) autocvar_g_balance_##wepname##_##name
#define WEP_CVAR_PRI(wepname,name) WEP_CVAR(wepname, primary_##name)
#define WEP_CVAR_SEC(wepname,name) WEP_CVAR(wepname, secondary_##name)
#define WEP_CVAR_BOTH(wepname,isprimary,name) ((isprimary) ? WEP_CVAR_PRI(wepname, name) : WEP_CVAR_SEC(wepname, name))

// set initialization values for weapon settings
#define WEP_SKIP_CVAR(unuseda,unusedb,unusedc,unusedd) /* skip cvars */
#define WEP_SET_PROP(wepid,wepname,type,prop,name) WEP_##wepid.prop = autocvar_g_balance_##wepname##_##name;

const int WEP_FIRST = 1;
#define WEP_LAST (Weapons_COUNT - 1)
WepSet WEPSET_ALL;
WepSet WEPSET_SUPERWEAPONS;

REGISTER_WEAPON(Null, NEW(Weapon));

#include "all.inc"

entity get_weaponinfo(int id)
{
	if (id >= WEP_FIRST && id <= WEP_LAST) {
		Weapon w = Weapons[id];
		if (w) return w;
	}
	return WEP_Null;
}

// TODO: remove after 0.8.2. Retains impulse number compatibility because 0.8.1 clients don't reload the weapons.cfg
#define WEP_HARDCODED_IMPULSES 22

// TODO: invert after 0.8.2. Will require moving 'best weapon' impulses
#define WEP_IMPULSE_BEGIN 230
#define WEP_IMPULSE_END bound(WEP_IMPULSE_BEGIN, WEP_IMPULSE_BEGIN + (Weapons_COUNT - 1) - 1, 253)

REGISTRY_SORT(Weapons, netname, WEP_HARDCODED_IMPULSES + 1)

STATIC_INIT(register_weapons_done)
{
	for (int i = 0; i < Weapons_COUNT; ++i) {
		Weapon it = Weapons[i];
		it.m_id = i;
		WepSet set = WepSet_FromWeapon(it.m_id);
		WEPSET_ALL |= set;
		if ((it.spawnflags) & WEP_FLAG_SUPERWEAPON) WEPSET_SUPERWEAPONS |= set;
		it.weapon = it.m_id;
		it.weapons = set;
		#ifdef CSQC
		it.wr_init(it);
		#endif
		int imp = WEP_IMPULSE_BEGIN + it.m_id - 1;
		if (imp <= WEP_IMPULSE_END)
			localcmd(sprintf("alias weapon_%s \"impulse %d\"\n", it.netname, imp));
		else
			LOG_TRACEF(_("Impulse limit exceeded, weapon will not be directly accessible: %s\n"), it.netname);
	}
	weaponorder_byid = "";
	for (int i = Weapons_MAX - 1; i >= 1; --i)
		if (Weapons[i])
			weaponorder_byid = strcat(weaponorder_byid, " ", ftos(i));
	weaponorder_byid = strzone(substring(weaponorder_byid, 1, strlen(weaponorder_byid) - 1));
}

#endif
