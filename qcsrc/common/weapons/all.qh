#ifndef WEAPONS_ALL_H
#define WEAPONS_ALL_H

#ifndef MENUQC
#include "calculations.qh"
#endif

#include "../util.qh"
#ifdef SVQC
#include "../../server/bot/aim.qh"
#endif
const int MAX_SHOT_DISTANCE = 32768;

// weapon pickup ratings for bot logic
const int BOT_PICKUP_RATING_LOW  =  2500;
const int BOT_PICKUP_RATING_MID  =  5000;
const int BOT_PICKUP_RATING_HIGH = 10000;

// weapon flags
const int WEP_TYPE_OTHER          =  0x00; // not for damaging people
const int WEP_TYPE_SPLASH         =  0x01; // splash damage
const int WEP_TYPE_HITSCAN        =  0x02; // hitscan
const int WEP_TYPEMASK            =  0x0F;
const int WEP_FLAG_CANCLIMB       =  0x10; // can be used for movement
const int WEP_FLAG_NORMAL         =  0x20; // in "most weapons" set
const int WEP_FLAG_HIDDEN         =  0x40; // hides from menu
const int WEP_FLAG_RELOADABLE     =  0x80; // can has reload
const int WEP_FLAG_SUPERWEAPON    = 0x100; // powerup timer
const int WEP_FLAG_MUTATORBLOCKED = 0x200; // hides from impulse 99 etc. (mutators are allowed to clear this flag)

// weapon requests
const int WR_SETUP          =  1; // (SERVER) setup weapon data
.bool(entity this) wr_setup;
const int WR_THINK          =  2; // (SERVER) logic to run every frame
.bool(entity this) wr_think;
const int WR_CHECKAMMO1     =  3; // (SERVER) checks ammo for weapon primary
.bool(entity this) wr_checkammo1;
const int WR_CHECKAMMO2     =  4; // (SERVER) checks ammo for weapon second
.bool(entity this) wr_checkammo2;
const int WR_AIM            =  5; // (SERVER) runs bot aiming code for this weapon
.bool(entity this) wr_aim;
const int WR_INIT           =  6; // (BOTH)   precaches models/sounds used by this weapon, also sets up weapon properties
.bool(entity this) wr_init;
const int WR_SUICIDEMESSAGE =  7; // (SERVER) notification number for suicide message (may inspect w_deathtype for details)
.bool(entity this) wr_suicidemessage;
const int WR_KILLMESSAGE    =  8; // (SERVER) notification number for kill message (may inspect w_deathtype for details)
.bool(entity this) wr_killmessage;
const int WR_RELOAD         =  9; // (SERVER) handles reloading for weapon
.bool(entity this) wr_reload;
const int WR_RESETPLAYER    = 10; // (SERVER) clears fields that the weapon may use
.bool(entity this) wr_resetplayer;
const int WR_IMPACTEFFECT   = 11; // (CLIENT) impact effect for weapon explosion
.bool(entity this) wr_impacteffect;
const int WR_PLAYERDEATH    = 12; // (SERVER) called whenever a player dies
.bool(entity this) wr_playerdeath;
const int WR_GONETHINK      = 13; // (SERVER) logic to run when weapon is lost
.bool(entity this) wr_gonethink;
const int WR_CONFIG         = 14; // (ALL)    dump weapon cvars to config in data directory (see: sv_cmd dumpweapons)
.bool(entity this) wr_config;
const int WR_ZOOMRETICLE    = 15; // (CLIENT) weapon specific zoom reticle
.bool(entity this) wr_zoomreticle;
const int WR_DROP           = 16; // (SERVER) the weapon is dropped
.bool(entity this) wr_drop;
const int WR_PICKUP         = 17; // (SERVER) a weapon is picked up
.bool(entity this) wr_pickup;

bool w_new(entity this, int req) {
    if (req == WR_SETUP) return this.wr_setup ? this.wr_setup(this) : false;
    if (req == WR_THINK) return this.wr_think ? this.wr_think(this) : false;
    if (req == WR_CHECKAMMO1) return this.wr_checkammo1 ? this.wr_checkammo1(this) : false;
    if (req == WR_CHECKAMMO2) return this.wr_checkammo2 ? this.wr_checkammo2(this) : false;
    if (req == WR_AIM) return this.wr_aim ? this.wr_aim(this) : false;
    if (req == WR_INIT) return this.wr_init ? this.wr_init(this) : false;
    if (req == WR_SUICIDEMESSAGE) return this.wr_suicidemessage ? this.wr_suicidemessage(this) : false;
    if (req == WR_KILLMESSAGE) return this.wr_killmessage ? this.wr_killmessage(this) : false;
    if (req == WR_RELOAD) return this.wr_reload ? this.wr_reload(this) : false;
    if (req == WR_RESETPLAYER) return this.wr_resetplayer ? this.wr_resetplayer(this) : false;
    if (req == WR_IMPACTEFFECT) return this.wr_impacteffect ? this.wr_impacteffect(this) : false;
    if (req == WR_PLAYERDEATH) return this.wr_playerdeath ? this.wr_playerdeath(this) : false;
    if (req == WR_GONETHINK) return this.wr_gonethink ? this.wr_gonethink(this) : false;
    if (req == WR_CONFIG) return this.wr_config ? this.wr_config(this) : false;
    if (req == WR_ZOOMRETICLE) return this.wr_zoomreticle ? this.wr_zoomreticle(this) : false;
    if (req == WR_DROP) return this.wr_drop ? this.wr_drop(this) : false;
    if (req == WR_PICKUP) return this.wr_pickup ? this.wr_pickup(this) : false;
    return false;
}

// variables:
string weaponorder_byid;

// weapon sets
typedef vector WepSet;
WepSet WepSet_FromWeapon(int a);
#ifdef SVQC
void WepSet_AddStat();
void WepSet_AddStat_InMap();
void WriteWepSet(float dest, WepSet w);
#endif
#ifdef CSQC
WepSet WepSet_GetFromStat();
WepSet WepSet_GetFromStat_InMap();
WepSet ReadWepSet();
#endif

// weapon name macros
const int WEP_FIRST = 1;
#define WEP_MAXCOUNT 24 // Increase as needed. Can be up to three times as much.
int WEP_COUNT;
#define WEP_LAST (WEP_FIRST + WEP_COUNT - 1)
WepSet WEPSET_ALL;
WepSet WEPSET_SUPERWEAPONS;

// functions:
entity get_weaponinfo(int id);
string W_FixWeaponOrder(string order, float complete);
string W_UndeprecateName(string s);
string W_NameWeaponOrder(string order);
string W_NumberWeaponOrder(string order);
string W_FixWeaponOrder_BuildImpulseList(string o);
string W_FixWeaponOrder_AllowIncomplete(string order);
string W_FixWeaponOrder_ForceComplete(string order);
void W_RandomWeapons(entity e, float n);

string GetAmmoPicture(.int ammotype);

#ifdef CSQC
.int GetAmmoFieldFromNum(int i);
int GetAmmoStat(.int ammotype);
#endif

string W_Sound(string w_snd);
string W_Model(string w_mdl);

// ammo types
.int ammo_shells;
.int ammo_nails;
.int ammo_rockets;
.int ammo_cells;
.int ammo_plasma;
.int ammo_fuel;
.int ammo_none;

// other useful macros
#define WEP_ACTION(wpn,wrequest) wpn.weapon_func(wpn, wrequest)
#define _WEP_ACTION(wpn,wrequest) WEP_ACTION(get_weaponinfo(wpn), wrequest)
#define WEP_AMMO(wpn) (WEP_##wpn.ammo_field) // only used inside weapon files/with direct name, don't duplicate prefix
#define WEP_NAME(wpn) ((get_weaponinfo(wpn)).message)


// ======================
//  Configuration Macros
// ======================

// create cvars for weapon settings
#define WEP_ADD_CVAR_NONE(wepname,name) [[last]] float autocvar_g_balance_##wepname##_##name;

#define WEP_ADD_CVAR_PRI(wepname,name) WEP_ADD_CVAR_NONE(wepname, primary_##name)
#define WEP_ADD_CVAR_SEC(wepname,name) WEP_ADD_CVAR_NONE(wepname, secondary_##name)
#define WEP_ADD_CVAR_BOTH(wepname,name) \
	WEP_ADD_CVAR_PRI(wepname, name) \
	WEP_ADD_CVAR_SEC(wepname, name)

#define WEP_ADD_CVAR(wepid,wepname,mode,name) WEP_ADD_CVAR_##mode(wepname, name)

// create properties for weapon settings
#define WEP_ADD_PROP(wepid,wepname,type,prop,name) \
	.type prop; \
	[[last]] type autocvar_g_balance_##wepname##_##name;

// read cvars from weapon settings
#define WEP_CVAR(wepname,name) autocvar_g_balance_##wepname##_##name
#define WEP_CVAR_PRI(wepname,name) WEP_CVAR(wepname, primary_##name)
#define WEP_CVAR_SEC(wepname,name) WEP_CVAR(wepname, secondary_##name)
#define WEP_CVAR_BOTH(wepname,isprimary,name) ((isprimary) ? WEP_CVAR_PRI(wepname, name) : WEP_CVAR_SEC(wepname, name))

// set initialization values for weapon settings
#define WEP_SKIP_CVAR(unuseda,unusedb,unusedc,unusedd) /* skip cvars */
#define WEP_SET_PROP(wepid,wepname,type,prop,name) WEP_##wepid.prop = autocvar_g_balance_##wepname##_##name;


// =====================
//  Weapon Registration
// =====================

/** fields which are explicitly/manually set are marked with "M", fields set automatically are marked with "A" */
CLASS(Weapon, Object)
	ATTRIB(Weapon, m_id, int, 0)
    /**
     * M: WEP_id    : WEP_...
     * you can recognize dummies when this == 0
     */
    ATTRIB(Weapon, weapon, int, 0);
    /** A: WEPSET_id : WEPSET_... */
    ATTRIB(Weapon, weapons, WepSet, '0 0 0');
    /** M: function  : w_... */
    ATTRIB(Weapon, weapon_func, bool(entity thiswep, int req), w_new);
    /** M: ammotype  : main ammo field */
    ATTRIB(Weapon, ammo_field, .int, ammo_none);
    /** M: impulse   : weapon impulse */
    ATTRIB(Weapon, impulse, int, -1);
    /** M: flags     : WEPSPAWNFLAG_... combined */
    ATTRIB(Weapon, spawnflags, int, 0);
    /** M: rating    : bot weapon priority */
    ATTRIB(Weapon, bot_pickupbasevalue, float, 0);
    /** M: color     : waypointsprite color */
    ATTRIB(Weapon, wpcolor, vector, '0 0 0');
    /** A: wpn-id    : wpn- sprite name */
    ATTRIB(Weapon, wpmodel, string, "");
    /** M: modelname : name of model (without g_ v_ or h_ prefixes) */
    ATTRIB(Weapon, mdl, string, "");
    /** A: modelname : full path to g_ model */
    ATTRIB(Weapon, model, string, "");
    /** M: simplemdl : simpleitems weapon model/image */
    ATTRIB(Weapon, w_simplemdl, string, "foobar");
    /** M: crosshair : per-weapon crosshair: "CrosshairImage Size" */
    ATTRIB(Weapon, w_crosshair, string, "gfx/crosshair1");
    /** A: crosshair : per-weapon crosshair size (argument two of "crosshair" field) */
    ATTRIB(Weapon, w_crosshair_size, float, 1);
    /** M: wepimg    : "weaponfoobar" side view image file of weapon. WEAPONTODO: Move out of skin files, move to common files */
    ATTRIB(Weapon, model2, string, "");
    /** M: refname   : reference name name */
    ATTRIB(Weapon, netname, string, "");
    /** M: wepname   : human readable name */
    ATTRIB(Weapon, message, string, "AOL CD Thrower");

	METHOD(Weapon, display, void(entity this, void(string name, string icon) returns)) {
		returns(this.message, this.model2 ? sprintf("/gfx/hud/%s/%s", cvar_string("menu_skin"), this.model2) : string_null);
	}

	CONSTRUCTOR(Weapon,
		bool(entity this, int req) function,
		.int ammotype,
		int i,
		int weapontype,
		float pickupbasevalue,
		vector clr,
		string modelname,
		string simplemdl,
		string crosshair,
		string wepimg,
		string refname,
		string wepname
	) {
		CONSTRUCT(Weapon);
		this.weapon_func = function;
		this.ammo_field = ammotype;
		this.impulse = i;
		this.spawnflags = weapontype;
		this.bot_pickupbasevalue = pickupbasevalue;
		this.wpcolor = clr;
		this.mdl = modelname;
		this.model = strzone(W_Model(strcat("g_", modelname, ".md3")));
		this.w_simplemdl = strzone(simplemdl); // simpleitems weapon model/image
		this.w_crosshair = strzone(car(crosshair));
		string s = cdr(crosshair);
		this.w_crosshair_size = ((s != "") ? stof(s) : 1); // so that we can scale the crosshair from code (for compat)
		this.model2 = strzone(wepimg);
		this.netname = refname;
		this.message = wepname;
	}
	void register_weapon(entity this, int id, WepSet bit)
	{
		this.classname = "weapon_info";
		this.weapon = id;
		this.weapons = bit;
		this.wpmodel = strzone(strcat("wpn-", ftos(id)));
		#ifdef CSQC
		this.weapon_func(this, WR_INIT);
		#endif
	}
ENDCLASS(Weapon)

void RegisterWeapons();
REGISTER_REGISTRY(RegisterWeapons)
entity weapon_info[WEP_MAXCOUNT], weapon_info_first, weapon_info_last;
entity dummy_weapon_info;

#define REGISTER_WEAPON(...) EVAL(OVERLOAD(REGISTER_WEAPON, __VA_ARGS__))

#define REGISTER_WEAPON_2(id, inst) \
	WepSet WEPSET_##id; \
	REGISTER(RegisterWeapons, WEP, weapon_info, WEP_COUNT, id, m_id, inst) { \
		this.m_id++; \
		WEPSET_ALL |= (WEPSET_##id = WepSet_FromWeapon(this.m_id)); \
		if ((this.spawnflags) & WEP_FLAG_SUPERWEAPON) WEPSET_SUPERWEAPONS |= WEPSET_##id; \
		register_weapon(this, this.m_id, WEPSET_##id); \
	} \
	REGISTER_INIT(WEP, id)

#define _REGISTER_WEAPON(id, function, ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname) \
	REGISTER_WEAPON_2(id, NEW(Weapon, function, ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname))

#ifndef MENUQC
	#define REGISTER_WEAPON_13(id, function, ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname) \
    	bool function(entity this, int); \
    	_REGISTER_WEAPON(id, function, ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname)
#else
	#define REGISTER_WEAPON_13(id, function, ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname) \
		_REGISTER_WEAPON(id, w_new,   ammotype, impulse, flags, rating, color, modelname, simplemdl, crosshair, wepimg, refname, wepname)
#endif

#include "all.inc"

#undef WEP_ADD_CVAR_MO_PRI
#undef WEP_ADD_CVAR_MO_SEC
#undef WEP_ADD_CVAR_MO_BOTH
#undef WEP_ADD_CVAR_MO_NONE
#undef WEP_ADD_CVAR
#undef WEP_ADD_PROP
void register_weapons_done();
ACCUMULATE_FUNCTION(RegisterWeapons, register_weapons_done)
#endif
