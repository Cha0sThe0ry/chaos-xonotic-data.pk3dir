#ifndef WEAPONS_ALL_H
#define WEAPONS_ALL_H

#include "../command/all.qh"
#include "config.qh"

// weapon sets
typedef vector WepSet;
#define WEPSET(id) WepSet_FromWeapon(WEP_##id.m_id)
WepSet WepSet_FromWeapon(int a);
#ifdef SVQC
void WepSet_AddStat();
void WepSet_AddStat_InMap();
void WriteWepSet(float dest, WepSet w);
#endif

#ifdef CSQC
WepSet WepSet_GetFromStat();
WepSet WepSet_GetFromStat_InMap();
WepSet ReadWepSet();
#endif

#include "weapon.qh"

#ifndef MENUQC
#include "calculations.qh"
#include "../models/all.qh"
#endif

#include "../util.qh"

#ifdef SVQC
#include "../../server/bot/aim.qh"
#endif

REGISTRY(Weapons, 72) // Increase as needed. Can be up to 72.
#define Weapons_from(i) _Weapons_from(i, WEP_Null)
#define get_weaponinfo(i) Weapons_from(i)
REGISTER_REGISTRY(RegisterWeapons)
STATIC_INIT(WeaponPickup) { FOREACH(Weapons, true, LAMBDA(it.m_pickup = NEW(WeaponPickup, it))); }


GENERIC_COMMAND(dumpweapons, "Dump all weapons into weapons_dump.txt") // WEAPONTODO: make this work with other progs than just server
{
    switch(request)
    {
        case CMD_REQUEST_COMMAND:
        {
            #ifdef SVQC
            wep_config_file = -1;
            wep_config_alsoprint = -1;
            string filename = argv(1);

            if(filename == "")
            {
                filename = "weapons_dump.cfg";
                wep_config_alsoprint = false;
            }
            else if(filename == "-")
            {
                filename = "weapons_dump.cfg";
                wep_config_alsoprint = true;
            }
            wep_config_file = fopen(filename, FILE_WRITE);

            if(wep_config_file >= 0)
            {
                Dump_Weapon_Settings();
                LOG_INFO(sprintf("Dumping weapons... File located in ^2data/data/%s^7.\n", filename));
                fclose(wep_config_file);
                wep_config_file = -1;
                wep_config_alsoprint = -1;
            }
            else
            {
                LOG_INFO(sprintf("^1Error: ^7Could not open file '%s'!\n", filename));
            }
            #else
            LOG_INFO(_("Weapons dump command only works with sv_cmd.\n"));
            #endif
            return;
        }

        default:
        case CMD_REQUEST_USAGE:
        {
            LOG_INFO(strcat("\nUsage:^3 ", GetProgramCommandPrefix(), " dumpweapons [filename]"));
            LOG_INFO("  Where 'filename' is the file to write (default is weapons_dump.cfg),\n");
            LOG_INFO("  if supplied with '-' output to console as well as default,\n");
            LOG_INFO("  if left blank, it will only write to default.\n");
            return;
        }
    }
}

#define REGISTER_WEAPON(id, inst) \
    /* WepSet WEPSET_##id; */ \
    REGISTER(RegisterWeapons, WEP, Weapons, id, m_id, inst)

// create cvars for weapon settings
#define WEP_ADD_CVAR_NONE(wepname,name) [[last]] float autocvar_g_balance_##wepname##_##name;

#define WEP_ADD_CVAR_PRI(wepname,name) WEP_ADD_CVAR_NONE(wepname, primary_##name)
#define WEP_ADD_CVAR_SEC(wepname,name) WEP_ADD_CVAR_NONE(wepname, secondary_##name)
#define WEP_ADD_CVAR_BOTH(wepname,name) \
    WEP_ADD_CVAR_PRI(wepname, name) \
    WEP_ADD_CVAR_SEC(wepname, name)

#define WEP_ADD_CVAR(wepid,wepname,mode,name) WEP_ADD_CVAR_##mode(wepname, name)

// create properties for weapon settings
#define WEP_ADD_PROP(wepid,wepname,type,prop,name) \
    .type prop; \
    [[last]] type autocvar_g_balance_##wepname##_##name;

// read cvars from weapon settings
#define WEP_CVAR(wepname,name) autocvar_g_balance_##wepname##_##name
#define WEP_CVAR_PRI(wepname,name) WEP_CVAR(wepname, primary_##name)
#define WEP_CVAR_SEC(wepname,name) WEP_CVAR(wepname, secondary_##name)
#define WEP_CVAR_BOTH(wepname,isprimary,name) ((isprimary) ? WEP_CVAR_PRI(wepname, name) : WEP_CVAR_SEC(wepname, name))

// set initialization values for weapon settings
#define WEP_SKIP_CVAR(unuseda,unusedb,unusedc,unusedd) /* skip cvars */
#define WEP_SET_PROP(wepid,wepname,type,prop,name) WEP_##wepid.prop = autocvar_g_balance_##wepname##_##name;

const int WEP_FIRST = 1;
#define WEP_LAST (Weapons_COUNT - 1)
WepSet WEPSET_ALL;
WepSet WEPSET_SUPERWEAPONS;

REGISTER_WEAPON(Null, NEW(Weapon));

#include "all.inc"

// TODO: remove after 0.8.2. Retains impulse number compatibility because 0.8.1 clients don't reload the weapons.cfg
#define WEP_HARDCODED_IMPULSES 20

// TODO: invert after 0.8.2. Will require moving 'best weapon' impulses
#define WEP_IMPULSE_BEGIN 230
#define WEP_IMPULSE_END bound(WEP_IMPULSE_BEGIN, WEP_IMPULSE_BEGIN + (Weapons_COUNT - 1) - 1, 253)

REGISTRY_SORT(Weapons, WEP_HARDCODED_IMPULSES + 1)
REGISTRY_CHECK(Weapons)

STATIC_INIT(register_weapons_done)
{
    FOREACH(Weapons, true, LAMBDA(
        it.m_id = i;
        WepSet set = WepSet_FromWeapon(it.m_id);
        WEPSET_ALL |= set;
        if ((it.spawnflags) & WEP_FLAG_SUPERWEAPON) WEPSET_SUPERWEAPONS |= set;
        it.weapon = it.m_id;
        it.weapons = set;
        int imp = WEP_IMPULSE_BEGIN + it.m_id - 1;
        if (imp <= WEP_IMPULSE_END)
            localcmd(sprintf("alias weapon_%s \"impulse %d\"\n", it.netname, imp));
        else
            LOG_TRACEF(_("Impulse limit exceeded, weapon will not be directly accessible: %s\n"), it.netname);
    ));
    #ifdef CSQC
    FOREACH(Weapons, true, LAMBDA(it.wr_init(it)));
    #endif
    weaponorder_byid = "";
    for (int i = Weapons_MAX - 1; i >= 1; --i)
        if (Weapons_from(i))
            weaponorder_byid = strcat(weaponorder_byid, " ", ftos(i));
    weaponorder_byid = strzone(substring(weaponorder_byid, 1, strlen(weaponorder_byid) - 1));
}

#ifndef MENUQC

.entity weaponchild;
.entity exteriorweaponentity;
.vector weaponentity_glowmod;

//.int weapon; // current weapon
.int switchweapon; // weapon requested to switch to
.int switchingweapon; // weapon currently being switched to (is copied from switchweapon once switch is possible)
.string weaponname; // name of .weapon

.vector spawnorigin; // for casings

// weapon animation vectors:
.vector anim_fire1;
.vector anim_fire2;
.vector anim_idle;
.vector anim_reload;

// static frame globals

ENUMCLASS(WFRAME)
CASE(WFRAME, DONTCHANGE)
CASE(WFRAME, FIRE1)
CASE(WFRAME, FIRE2)
CASE(WFRAME, IDLE)
CASE(WFRAME, RELOAD)
ENUMCLASS_END(WFRAME)

.WFRAME wframe;

vector shotorg_adjust_values(vector vecs, bool y_is_right, bool visual, int algn);
void CL_WeaponEntity_SetModel(entity this, string name);
#endif

#endif
