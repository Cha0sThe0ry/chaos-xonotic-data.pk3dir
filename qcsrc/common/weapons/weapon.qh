#ifndef WEAPON_H
#define WEAPON_H

.int ammo_shells;
.int ammo_nails;
.int ammo_rockets;
.int ammo_cells;
.int ammo_plasma;
.int ammo_fuel;
.int ammo_none;

/** fields which are explicitly/manually set are marked with "M", fields set automatically are marked with "A" */
CLASS(Weapon, Object)
	ATTRIB(Weapon, m_id, int, 0)
    /**
     * M: WEP_id    : WEP_...
     * you can recognize dummies when this == 0
     */
    ATTRIB(Weapon, weapon, int, 0);
    /** A: WEPSET_id : WEPSET_... */
    ATTRIB(Weapon, weapons, WepSet, '0 0 0');
    /** M: ammotype  : main ammo field */
    ATTRIB(Weapon, ammo_field, .int, ammo_none);
    /** M: impulse   : weapon impulse */
    ATTRIB(Weapon, impulse, int, -1);
    /** M: flags     : WEPSPAWNFLAG_... combined */
    ATTRIB(Weapon, spawnflags, int, 0);
    /** M: rating    : bot weapon priority */
    ATTRIB(Weapon, bot_pickupbasevalue, float, 0);
    /** M: color     : waypointsprite color */
    ATTRIB(Weapon, wpcolor, vector, '0 0 0');
    /** M: modelname : name of model (without g_ v_ or h_ prefixes) */
    ATTRIB(Weapon, mdl, string, "");
    /** M: model MDL_id_ITEM */
    ATTRIB(Weapon, m_model, entity, NULL);
    /** M: crosshair : per-weapon crosshair: "CrosshairImage Size" */
    ATTRIB(Weapon, w_crosshair, string, "gfx/crosshair1");
    /** A: crosshair : per-weapon crosshair size (argument two of "crosshair" field) */
    ATTRIB(Weapon, w_crosshair_size, float, 1);
    /** M: wepimg    : "weaponfoobar" side view image file of weapon. WEAPONTODO: Move out of skin files, move to common files */
    ATTRIB(Weapon, model2, string, "");
    /** M: refname   : reference name name */
    ATTRIB(Weapon, netname, string, "");
    /** M: wepname   : human readable name */
    ATTRIB(Weapon, message, string, "AOL CD Thrower");

    /** (SERVER) setup weapon data */
    METHOD(Weapon, wr_setup, void(Weapon this)) {}
    /** (SERVER) logic to run every frame */
    METHOD(Weapon, wr_think, void(Weapon this, entity actor, bool fire1, bool fire2)) {}
    /** (SERVER) checks ammo for weapon primary */
    METHOD(Weapon, wr_checkammo1, bool(Weapon this)) {return false;}
    /** (SERVER) checks ammo for weapon second */
    METHOD(Weapon, wr_checkammo2, bool(Weapon this)) {return false;}
    /** (SERVER) runs bot aiming code for this weapon */
    METHOD(Weapon, wr_aim, void(Weapon this)) {}
    /** (BOTH)   precaches models/sounds used by this weapon, also sets up weapon properties */
    METHOD(Weapon, wr_init, void(Weapon this)) {}
    /** (SERVER) notification number for suicide message (may inspect w_deathtype for details) */
    METHOD(Weapon, wr_suicidemessage, int(Weapon this)) {return 0;}
    /** (SERVER) notification number for kill message (may inspect w_deathtype for details) */
    METHOD(Weapon, wr_killmessage, int(Weapon this)) {return 0;}
    /** (SERVER) handles reloading for weapon */
    METHOD(Weapon, wr_reload, void(Weapon this)) {}
    /** (SERVER) clears fields that the weapon may use */
    METHOD(Weapon, wr_resetplayer, void(Weapon this)) {}
    /** (CLIENT) impact effect for weapon explosion */
    METHOD(Weapon, wr_impacteffect, void(Weapon this)) {}
    /** (SERVER) called whenever a player dies */
    METHOD(Weapon, wr_playerdeath, void(Weapon this)) {}
    /** (SERVER) logic to run when weapon is lost */
    METHOD(Weapon, wr_gonethink, void(Weapon this)) {}
    /** (ALL)    dump weapon cvars to config in data directory (see: sv_cmd dumpweapons) */
    METHOD(Weapon, wr_config, void(Weapon this)) {}
    /** (CLIENT) weapon specific zoom reticle */
    METHOD(Weapon, wr_zoomreticle, bool(Weapon this)) {
        // no weapon specific image for this weapon
        return false;
    }
    /** (SERVER) the weapon is dropped */
    METHOD(Weapon, wr_drop, void(Weapon this)) {}
    /** (SERVER) a weapon is picked up */
    METHOD(Weapon, wr_pickup, void(Weapon this)) {}

	METHOD(Weapon, display, void(entity this, void(string name, string icon) returns)) {
		returns(this.message, this.model2 ? sprintf("/gfx/hud/%s/%s", cvar_string("menu_skin"), this.model2) : string_null);
	}
ENDCLASS(Weapon)

CLASS(OffhandWeapon, Object)
    METHOD(OffhandWeapon, offhand_think, void(OffhandWeapon this, entity player, bool key_pressed)) {}
ENDCLASS(OffhandWeapon)

#ifdef SVQC
.OffhandWeapon offhand;
#endif

const int MAX_SHOT_DISTANCE = 32768;

// weapon pickup ratings for bot logic
const int BOT_PICKUP_RATING_LOW  =  2500;
const int BOT_PICKUP_RATING_MID  =  5000;
const int BOT_PICKUP_RATING_HIGH = 10000;

// weapon flags
const int WEP_TYPE_OTHER          =  0x00; // not for damaging people
const int WEP_TYPE_SPLASH         =  0x01; // splash damage
const int WEP_TYPE_HITSCAN        =  0x02; // hitscan
const int WEP_TYPEMASK            =  0x0F;
const int WEP_FLAG_CANCLIMB       =  0x10; // can be used for movement
const int WEP_FLAG_NORMAL         =  0x20; // in "most weapons" set
const int WEP_FLAG_HIDDEN         =  0x40; // hides from menu
const int WEP_FLAG_RELOADABLE     =  0x80; // can has reload
const int WEP_FLAG_SUPERWEAPON    = 0x100; // powerup timer
const int WEP_FLAG_MUTATORBLOCKED = 0x200; // hides from impulse 99 etc. (mutators are allowed to clear this flag)

// variables:
string weaponorder_byid;

// functions:
string W_FixWeaponOrder(string order, float complete);
string W_UndeprecateName(string s);
string W_NameWeaponOrder(string order);
string W_NumberWeaponOrder(string order);
string W_FixWeaponOrder_BuildImpulseList(string o);
string W_FixWeaponOrder_AllowIncomplete(string order);
string W_FixWeaponOrder_ForceComplete(string order);
void W_RandomWeapons(entity e, float n);

string GetAmmoPicture(.int ammotype);

#ifdef CSQC
.int GetAmmoFieldFromNum(int i);
int GetAmmoStat(.int ammotype);
#endif

string W_Sound(string w_snd);
string W_Model(string w_mdl);


// other useful macros
#define WEP_AMMO(wpn) (WEP_##wpn.ammo_field) // only used inside weapon files/with direct name, don't duplicate prefix
#define WEP_NAME(wpn) ((get_weaponinfo(wpn)).message)

#endif
