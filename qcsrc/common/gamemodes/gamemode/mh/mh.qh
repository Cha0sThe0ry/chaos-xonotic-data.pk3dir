#pragma once

#include <common/mapinfo.qh>

bool autocvar_g_mh_not_dm_maps;

#ifdef CSQC
void HUD_Mod_MH(vector pos, vector mySize);
#endif
CLASS(Manhunt, Gametype)
	INIT(Manhunt)
	{
		this.gametype_init(this, _("Tag Manhunt"),"mh","g_mh",GAMETYPE_FLAG_TEAMPLAY | GAMETYPE_FLAG_USEPOINTS | GAMETYPE_FLAG_PRIORITY,"","timelimit=30 pointlimit=10 teams=2 leadlimit=0",_("Avoid getting tagged yourself and once tagged go catch as many untagged players as possible"));
	}
	METHOD(Manhunt, m_isAlwaysSupported, bool(Gametype this, int spawnpoints, float diameter))
	{
		if(spawnpoints >= 2 && diameter > 4096)
			return true;
		return false;
	}
	METHOD(Manhunt, m_isForcedSupported, bool(Gametype this))
	{
		if(!autocvar_g_mh_not_dm_maps)
		{
			// if this is unset, all DM maps support MH too
			if(!(MapInfo_Map_supportedGametypes & this.m_flags) && (MapInfo_Map_supportedGametypes & MAPINFO_TYPE_DEATHMATCH.m_flags))
				return true; // TODO: references another gametype (alternatively, we could check which gamemodes are always enabled and append this if any are supported)
		}

		return false;
	}
	
	//is g_mh_teams_override just removeable as there will only ever be 2 teams or does it need to be replaced something like 2 or "null"?
	METHOD(Manhunt, m_configuremenu, void(Gametype this, entity menu, void(entity me, string pLabel, float pMin, float pMax, float pStep, string pCvar, string tCvar, string pTooltip) returns))
	{
		TC(Gametype, this);
		returns(menu, _("Point limit:"),     5,  100,  5, "g_mh_point_limit",         "g_mh_teams_override",         _("The amount of points needed before the match will end"));
	}
#ifdef CSQC
    ATTRIB(Manhunt, m_modicons, void(vector pos, vector mySize), HUD_Mod_MH);
#endif
	ATTRIB(Manhunt, m_legacydefaults, string, "50 20 2 0");
ENDCLASS(Manhunt)
REGISTER_GAMETYPE(MANHUNT, NEW(Manhunt));
#define g_mh IS_GAMETYPE(MANHUNT)

#ifdef GAMEQC
// shared state signalling the player's mh status
.int mh_status;
const int MH_STATUS_HUNTER = 1;
const int MH_STATUS_RUNNER = 2;
#endif

// Hunters can't look anything until round starts
REGISTER_NET_TEMP(TE_CSQC_HUNTEREYES);

#ifdef CSQC
#include <client/draw.qh>
#include <client/hud/hud.qh>

float huntereyes_appeartime;
float huntereyes_fadetime;

void HUD_HunterEyes()
{
	vector bottomright = vec2(vid_conwidth, vid_conheight);
	// drawfill function parameters (qcsrc/dpdefs/menudefs.qc):
	// float drawfill(vector position, vector size, vector rgb, float alpha, float flag)
	drawfill('0 0 0', bottomright, '0 0 0', 1, DRAWFLAG_NORMAL);
}

#elif defined(SVQC)
#include <server/command/common.qh>

void HunterEyesStart(entity e)
{
	if(e == NULL)
		return;

	int accepted = VerifyClientEntity(e, true, false);

	if(accepted > 0) 
	{
		msg_entity = e;
		WriteHeader(MSG_ONE, TE_CSQC_HUNTEREYES);
	}
}
#endif

#ifdef CSQC

bool eyesblinded;

REGISTER_MUTATOR(cl_hunteryes, true);

MUTATOR_HOOKFUNCTION(cl_hunteryes, DrawScoreboard)
{
	return eyesblinded;
}

MUTATOR_HOOKFUNCTION(cl_hunteryes, HUD_Draw_overlay)
{
	if(!eyesblinded)
		return false;

	if(!STAT(GAME_STOPPED) && !warmup_stage && STAT(MH_ROUNDTIMER) > 0)
		eyesblinded = false;

	if(time <= huntereyes_fadetime)
	{
		HUD_HunterEyes();
		return false;
	}
	else
		eyesblinded = false;

	return false;
}

NET_HANDLE(TE_CSQC_HUNTEREYES, bool isNew)
{
	return = true;

	if(eyesblinded)
		return;

	eyesblinded = true;
	huntereyes_appeartime = time;
	huntereyes_fadetime = time + cvar("g_mh_warmup");
}
#endif