#pragma once

#include <common/gamemodes/gamemode/deathmatch/deathmatch.qh>
#include <common/mapinfo.qh>

bool autocvar_g_br_not_dm_maps;

#ifdef CSQC
void HUD_Mod_BR(vector pos, vector mySize);
void HUD_Mod_BR_Export(int fh);
#endif
#ifdef SVQC
IntrusiveList squads;
#endif
CLASS(BattleRoyale, Gametype)
#ifdef SVQC
    STATIC_INIT(BattleRoyale)
    {
        squads = IL_NEW();
    }
#endif
    INIT(BattleRoyale)
    {
        this.gametype_init(this, _("Battle Royale"),"br","g_br",GAMETYPE_FLAG_HIDELIMITS,"","",_("Survive and kill until there are no enemies left"));
    }
    METHOD(BattleRoyale, m_isAlwaysSupported, bool(Gametype this, int spawnpoints, float diameter))
    {
        if(diameter > 4096)
            return true;
        return false;
    }
    METHOD(BattleRoyale, m_isForcedSupported, bool(Gametype this))
	{
		if(!autocvar_g_br_not_dm_maps)
		{
			// if this is unset, all DM maps support BR too
			if(!(MapInfo_Map_supportedGametypes & this.m_flags) && (MapInfo_Map_supportedGametypes & MAPINFO_TYPE_DEATHMATCH.m_flags))
				return true; // TODO: references another gametype (alternatively, we could check which gamemodes are always enabled and append this if any are supported)
		}

		return false;
	}

#ifdef CSQC
    ATTRIB(BattleRoyale, m_modicons, void(vector pos, vector mySize), HUD_Mod_BR);
    ATTRIB(BattleRoyale, m_modicons_export, void(int fh), HUD_Mod_BR_Export);
#endif
ENDCLASS(BattleRoyale)
REGISTER_GAMETYPE(BR, NEW(BattleRoyale));
#define g_br IS_GAMETYPE(BR)

#ifdef GAMEQC
const int DROP_LANDED    = 0;
const int DROP_FALLING   = 1;
const int DROP_TRANSPORT = 2;
#endif
