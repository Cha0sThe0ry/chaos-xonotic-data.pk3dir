float BOT_PICKUP_RATING_LOW	= 2500;
float BOT_PICKUP_RATING_MID	= 5000;
float BOT_PICKUP_RATING_HIGH	= 10000;

float WEP_TYPE_OTHER	    =  0x00;	// e.g: Hook, Port-o-launch, etc
float WEP_TYPE_SPLASH	    =  0x01;
float WEP_TYPE_HITSCAN	    =  0x02;
float WEP_TYPEMASK          =  0x0F;
float WEP_FLAG_CANCLIMB     =  0x10;
float WEP_FLAG_NORMAL       =  0x20;
float WEP_FLAG_HIDDEN       =  0x40;
float WEP_FLAG_RELOADABLE   =  0x80;
float WEP_FLAG_SUPERWEAPON  = 0x100;

float	IT_UNLIMITED_WEAPON_AMMO     = 1;
// when this bit is set, using a weapon does not reduce ammo. Checkpoints can give this powerup.
float	IT_UNLIMITED_SUPERWEAPONS    = 2;
// when this bit is set, superweapons don't expire. Checkpoints can give this powerup.
float   IT_CTF_SHIELDED              = 4; // set for the flag shield
float   IT_USING_JETPACK             = 8; // confirmation that button is pressed
float   IT_JETPACK                   = 16; // actual item
float   IT_FUEL_REGEN                = 32; // fuel regeneration trigger
float   IT_SHELLS                    = 256;
float   IT_NAILS                     = 512;
float   IT_ROCKETS                   = 1024;
float   IT_CELLS                     = 2048;
float   IT_SUPERWEAPON               = 4096;
float   IT_FUEL                      = 128;
float   IT_STRENGTH                  = 8192;
float   IT_INVINCIBLE                = 16384;
float   IT_HEALTH                    = 32768;
// union:
        // for items:
        float   IT_KEY1              = 131072;
        float   IT_KEY2              = 262144;
        // for players:
        float   IT_RED_FLAG_TAKEN    = 32768;
        float   IT_RED_FLAG_LOST     = 65536;
        float   IT_RED_FLAG_CARRING  = 98304;
        float   IT_BLUE_FLAG_TAKEN   = 131072;
        float   IT_BLUE_FLAG_LOST    = 262144;
        float   IT_BLUE_FLAG_CARRING = 393216;
// end
float   IT_5HP                       = 524288;
float   IT_25HP                      = 1048576;
float   IT_ARMOR_SHARD               = 2097152;
float   IT_ARMOR                     = 4194304;

float   IT_AMMO                      = 3968; // IT_SHELLS | IT_NAILS | IT_ROCKETS | IT_CELLS | IT_FUEL;
float   IT_PICKUPMASK                = 51; // IT_FUEL_REGEN | IT_JETPACK | IT_UNLIMITED_AMMO; // strength and invincible are handled separately
float   IT_UNLIMITED_AMMO            = 3; // IT_UNLIMITED_SUPERWEAPONS | IT_UNLIMITED_WEAPON_AMMO;

float AMMO_COUNT = 4; // amount of ammo types to show in the inventory panel

// variables:
string weaponorder_byid;

// functions:
entity get_weaponinfo(float id);
string W_FixWeaponOrder(string order, float complete);
string W_NameWeaponOrder(string order);
string W_NumberWeaponOrder(string order);

// ammo types
.float ammo_shells;
.float ammo_nails;
.float ammo_rockets;
.float ammo_cells;
.float ammo_fuel;
.float ammo_batteries; // dummy

// entity properties of weaponinfo:
.float weapon; // WEP_...
.float weapons; // WEPBIT_...
.string netname; // short name
.string message; // human readable name
.float items; // IT_...
.float(float) weapon_func; // w_...
.string mdl; // modelname without g_, v_, w_
.string model; // full name of g_ model
.float spawnflags; // WEPSPAWNFLAG_... combined
.float impulse; // weapon impulse
.float bot_pickupbasevalue; // bot weapon priority
.string model2; // wpn- sprite name
..float ammo_field; // main ammo field

// dynamic weapon adding
float w_null(float dummy);
void register_weapon(float id, float(float) func, float ammotype, float i, float weapontype, float pickupbasevalue, string modelname, string shortname, string wname);
void register_weapons_done();

#if 1
.float weapons;
# define WEPSET_DECLARE_A(a) float _WS_##a

# define WEPSET_CLEAR_E(e) ((e).weapons = 0)
# define WEPSET_CLEAR_A(a) ((_WS_##a) = 0)

# define WEPSET_EMPTY_E(e) ((e).weapons == 0)
# define WEPSET_EMPTY_A(a) ((_WS_##a) == 0)

# define WEPSET_COPY_EE(e,o) ((e).weapons = (o).weapons)
# define WEPSET_EQ_EE(e,o) ((e).weapons == (o).weapons)
# define WEPSET_OR_EE(e,o) ((e).weapons |= (o).weapons)
# define WEPSET_AND_EE(e,o) ((e).weapons &= (o).weapons)
# define WEPSET_ANDNOT_EE(e,o) ((e).weapons &~= (o).weapons)
# define WEPSET_CONTAINS_ANY_EE(e,o) !!((e).weapons & (o).weapons)
# define WEPSET_CONTAINS_ALL_EE(e,o) !!(((e).weapons & (o).weapons) == (e).weapons)

# define WEPSET_COPY_EA(e,a) ((e).weapons = (_WS_##a))
# define WEPSET_EQ_EA(e,a) ((e).weapons == (_WS_##a))
# define WEPSET_OR_EA(e,a) ((e).weapons |= (_WS_##a))
# define WEPSET_AND_EA(e,a) ((e).weapons &= (_WS_##a))
# define WEPSET_ANDNOT_EA(e,a) ((e).weapons &~= (_WS_##a))
# define WEPSET_CONTAINS_ANY_EA(e,a) !!((e).weapons & (_WS_##a))
# define WEPSET_CONTAINS_ALL_EA(e,a) !!(((e).weapons & (_WS_##a)) == (_WS_##a))

# define WEPSET_COPY_EW(e,w) ((e).weapons = power2of((w) - WEP_FIRST))
# define WEPSET_EQ_EW(e,w) ((e).weapons == power2of((w) - WEP_FIRST))
# define WEPSET_OR_EW(e,w) ((e).weapons |= power2of((w) - WEP_FIRST))
# define WEPSET_AND_EW(e,w) ((e).weapons &= power2of((w) - WEP_FIRST))
# define WEPSET_ANDNOT_EW(e,w) ((e).weapons &~= power2of((w) - WEP_FIRST))
# define WEPSET_CONTAINS_EW(e,w) !!((e).weapons & power2of((w) - WEP_FIRST))

# define WEPSET_COPY_AE(a,e) ((_WS_##a) = (e).weapons)
# define WEPSET_EQ_AE(a,e) ((_WS_##a) == (e).weapons)
# define WEPSET_OR_AE(a,e) ((_WS_##a) |= (e).weapons)
# define WEPSET_AND_AE(a,e) ((_WS_##a) &= (e).weapons)
# define WEPSET_ANDNOT_AE(a,e) ((_WS_##a) &~= (e).weapons)
# define WEPSET_CONTAINS_ANY_AE(a,e) !!((_WS_##a) & (e).weapons)
# define WEPSET_CONTAINS_ALL_AE(a,e) !!(((_WS_##a) & (e).weapons) == (e))

# define WEPSET_COPY_AA(a,b) ((_WS_##a) = (_WS_##b))
# define WEPSET_EQ_AA(a,b) ((_WS_##a) == (_WS_##b))
# define WEPSET_OR_AA(a,b) ((_WS_##a) |= (_WS_##b))
# define WEPSET_AND_AA(a,b) ((_WS_##a) &= (_WS_##b))
# define WEPSET_ANDNOT_AA(a,b) ((_WS_##a) &~= (_WS_##b))
# define WEPSET_CONTAINS_ANY_AA(a,b) !!((_WS_##a) & (_WS_##b))
# define WEPSET_CONTAINS_ALL_AA(a,b) !!(((_WS_##a) & (_WS_##b)) == (_WS_##b))

# define WEPSET_COPY_AW(a,w) ((_WS_##a) = power2of((w) - WEP_FIRST))
# define WEPSET_EQ_AW(a,w) ((_WS_##a) == power2of((w) - WEP_FIRST))
# define WEPSET_OR_AW(a,w) ((_WS_##a) |= power2of((w) - WEP_FIRST))
# define WEPSET_AND_AW(a,w) ((_WS_##a) &= power2of((w) - WEP_FIRST))
# define WEPSET_ANDNOT_AW(a,w) ((_WS_##a) &~= power2of((w) - WEP_FIRST))
# define WEPSET_CONTAINS_AW(a,w) !((_WS_##a) & power2of((w) - WEP_FIRST))

# ifdef CSQC
#  define WEPSET_COPY_AS(a) ((_WS_##a) = getstatf(STAT_WEAPONS))
# endif
#endif

float WEP_COUNT;
float WEP_FIRST = 1;
float WEP_LAST;
#define WEP_MAXCOUNT 24
WEPSET_DECLARE_A(WEPBIT_ALL);
WEPSET_DECLARE_A(WEPBIT_SUPERWEAPONS);
// note: the fabs call is just there to hide "if result is constant" warning
#define REGISTER_WEAPON_2(id,bit,func,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname) \
	float id; \
	float func(float); \
	void RegisterWeapons_##id() \
	{ \
		WEP_LAST = (id = WEP_FIRST + WEP_COUNT); \
		WEPSET_OR_AW(WEPBIT_ALL, id); \
		if(fabs(weapontype & WEP_FLAG_SUPERWEAPON)) \
			WEPSET_OR_AW(WEPBIT_SUPERWEAPONS, id); \
		++WEP_COUNT; \
		register_weapon(id,func,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname); \
	} \
	ACCUMULATE_FUNCTION(RegisterWeapons, RegisterWeapons_##id)
#ifdef MENUQC
#define REGISTER_WEAPON(id,func,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname) \
	REGISTER_WEAPON_2(WEP_##id,WEPBIT_##id,w_null,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname)
#else
#define REGISTER_WEAPON(id,func,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname) \
	REGISTER_WEAPON_2(WEP_##id,WEPBIT_##id,func,ammotype,i,weapontype,pickupbasevalue,modelname,shortname,wname)
#endif

#include "../server/w_all.qc"

#undef REGISTER_WEAPON
ACCUMULATE_FUNCTION(RegisterWeapons, register_weapons_done)


string W_FixWeaponOrder(string order, float complete);
string W_NumberWeaponOrder(string order);
string W_NameWeaponOrder(string order);
string W_FixWeaponOrder_BuildImpulseList(string o);
string W_FixWeaponOrder_AllowIncomplete(string order);
string W_FixWeaponOrder_ForceComplete(string order);
