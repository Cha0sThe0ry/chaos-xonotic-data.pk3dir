#pragma once

// TODO: rename to 'netvars'

#include "registry.qh"
#include "sort.qh"

.int m_id;
USING(vectori, vector);

REGISTRY(Stats, 256)
REGISTER_REGISTRY(Stats)
REGISTRY_SORT(Stats)
REGISTRY_CHECK(Stats)
STATIC_INIT(Stats_renumber) { FOREACH(Stats, true, it.m_id = i); }

REGISTRY_DEFINE_GET(Stats, NULL)

#define REGISTER_STAT(...) EVAL_REGISTER_STAT(OVERLOAD(REGISTER_STAT, __VA_ARGS__))
#define EVAL_REGISTER_STAT(...) __VA_ARGS__

#if defined(CSQC)
	#define stats_get_int() ReadInt24_t()
	#define stats_get_bool() boolean(ReadByte())
	#define stats_get_float() ReadFloat()
	#define stats_get_vector() ReadVector()
	#define stats_get_vectori() ReadInt72_t()

.void(entity ent) m_receive;
#elif defined(SVQC)
	#define stats_write_int(chan,id,ent) WriteInt24_t(chan, STAT(id, ent))
	#define stats_write_bool(chan,id,ent) WriteByte(chan, STAT(id, ent))
	#define stats_write_float(chan,id,ent) WriteFloat(chan, STAT(id, ent))
	#define stats_write_vector(chan,id,ent) WriteVector(chan, STAT(id, ent))
	#define stats_write_vectori(chan,id,ent) WriteInt72_t(chan, STAT(id, ent))

.bool(entity ent, entity player) m_check;
.void(entity ent, entity player) m_set;
.void(int chan, entity ent) m_send;
#endif

#if defined(CSQC)
	#define STAT(...) EVAL_STAT(OVERLOAD(STAT, __VA_ARGS__))
	#define EVAL_STAT(...) __VA_ARGS__
    #define STAT_1(id) (RVALUE, _STAT(id))
	#define STAT_2(id, cl) STAT_1(id)

	#define _STAT(id) g_stat_##id
	#define REGISTER_STAT_2(id, T) \
		T _STAT(id); \
		/* T CAT(_STAT(id), _prev); */ \
		void STAT_##id##_receive(entity data) { _STAT(id) = stats_get_##T(); } \
		REGISTER(Stats, STAT_##id, m_id, new_pure(stat)) \
		{ \
			this.m_receive = STAT_##id##_receive; \
		}
	#define REGISTER_STAT_3(x, T, expr) REGISTER_STAT_2(x, T)
#elif defined(SVQC)
    /** Internal use only */
    entity STATS;
	/** Add all registered stats, access with `STAT(ID, player)` or `.type stat = _STAT(ID); player.stat` */
	#define STAT(...) EVAL_STAT(OVERLOAD_(STAT, __VA_ARGS__))
    #define EVAL_STAT(...) __VA_ARGS__
    #define STAT_1(id) (RVALUE, STAT_2(id, STATS))
	#define STAT_2(id, cl) (cl)._STAT(id)

	STATIC_INIT(stats)
	{
	    STATS = new_pure(stats);
	}

	#define _STAT(id) stat_##id
	#define REGISTER_STAT_2(id, T) \
		.T _STAT(id); \
		bool STAT_##id##_check(entity ent, entity player) { return STAT(id, ent) != STAT(id, player); } \
		void STAT_##id##_set(entity ent, entity player) { STAT(id, ent) = STAT(id, player); } \
		void STAT_##id##_send(int chan, entity ent) { stats_write_##T(chan, id, ent); } \
		REGISTER(Stats, STAT_##id, m_id, new_pure(stat)) \
		{ \
			this.m_check = STAT_##id##_check; \
			this.m_set = STAT_##id##_set; \
			this.m_send = STAT_##id##_send; \
		}
	void GlobalStats_update(entity this) {}
	void GlobalStats_updateglobal() {}
    /** TODO: do we want the global copy to update? */
    #define REGISTER_STAT_3(id, T, expr) \
    	REGISTER_STAT_2(id, T); \
    	ACCUMULATE void GlobalStats_update(entity this) { STAT(id, this) = (expr); } \
    	ACCUMULATE void GlobalStats_updateglobal() { entity this = STATS; STAT(id, this) = (expr); } \
    	STATIC_INIT(worldstat_##id) { entity this = STATS; STAT(id, this) = (expr); }
#else
	#define REGISTER_STAT_2(id, type)
    #define REGISTER_STAT_3(id, T, expr)
#endif

#ifdef GAMEQC
/** Player stats */
.entity stats;

REGISTER_NET_LINKED(ENT_CLIENT_STATS)

const int Stats_groups_minor = 16; // must be a multiple of 8 (one byte) to optimize bandwidth usage
const int Stats_groups_major = 16; // ceil(REGISTRY_MAX(Stats) / Stats_groups_minor)
#endif

#ifdef SVQC
#define G_MAJOR(id) (floor((id) / Stats_groups_minor))
#define G_MINOR(id) ((id) % Stats_groups_minor)
#endif

#ifdef CSQC
NET_HANDLE(ENT_CLIENT_STATS, bool isnew)
{
    make_pure(this);
    const int majorBits = Readbits(Stats_groups_major);
    for (int i = 0; i < Stats_groups_major; ++i) {
        if (!(majorBits & BIT(i))) {
            continue;
        }
        const int minorBits = Readbits(Stats_groups_minor);
        for (int j = 0; j < Stats_groups_minor; ++j) {
            if (!(minorBits & BIT(j))) {
                continue;
            }
            const entity it = REGISTRY_GET(Stats, Stats_groups_minor * i + j);
            it.m_receive(it);
        }
    }
    return true;
}
#endif

#ifdef SVQC
int statsminorBitsArr[Stats_groups_major];
void Stats_Write(entity data)
{
    if (!data) {
        WriteShort(MSG_ENTITY, 0);
        return;
    }
    TC(entity, data);

	for (int i = 0; i < Stats_groups_major; ++i)
		statsminorBitsArr[i] = 0;

    int majorBits = 0;
    FOREACH(Stats, true, {
        const bool changed = it.m_check(data, data.owner);
        if (changed) {
        	it.m_set(data, data.owner);
			int maj = G_MAJOR(it.m_id);
			majorBits = BITSET(majorBits, BIT(maj), true);
			statsminorBitsArr[maj] = BITSET(statsminorBitsArr[maj], BIT(G_MINOR(it.m_id)), true);
        }
    });
    Writebits(MSG_ENTITY, majorBits, Stats_groups_major);

	for (int i = 0; i < Stats_groups_major; ++i)
	{
		if (!(majorBits & BIT(i)))
			continue;

		const int minorBits = statsminorBitsArr[i];
		Writebits(MSG_ENTITY, minorBits, Stats_groups_minor);
		for (int j = 0; j < Stats_groups_minor; ++j)
		{
			if (!(minorBits & BIT(j)))
				continue;

			const entity it = REGISTRY_GET(Stats, Stats_groups_minor * i + j);
            it.m_send(MSG_ENTITY, data);
		}
	}
}
#endif

#ifdef SVQC
#undef G_MAJOR
#undef G_MINOR
#endif

#ifdef SVQC
bool Stats_Send(entity this, entity to, int sf)
{
    TC(entity, this);
    WriteHeader(MSG_ENTITY, ENT_CLIENT_STATS);
    TC(entity, this.owner);
    Stats_Write(this);
    return true;
}

void Stats_update(entity e) { e.stats.SendFlags = 0xFFFFFF; }
void Stats_checkupdate(entity this)
{
	FOREACH(Stats, true, {
		const bool changed = it.m_check(this, this.owner);
		if(changed)
		{
			Stats_update(this.owner);
			break; // no need to keep looping once we've found a stat that needs updating
		}
	});

	this.nextthink = time;
}

void Stats_new(entity this)
{
    entity ent = new_pure(Stats);
    setthink(ent, Stats_checkupdate);
    ent.nextthink = time;
    ent.drawonlytoclient = this;
    Net_LinkEntity((ent.owner = this).stats = ent, false, 0, Stats_Send);
}
void Stats_delete(entity e) { delete(e.stats); }
#endif
