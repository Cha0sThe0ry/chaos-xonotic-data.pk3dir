#ifndef REGISTRY_H
#define REGISTRY_H

#include "oo.qh"

#define REGISTER_REGISTRY(func) ACCUMULATE_FUNCTION(__static_init, func)

#define REGISTER_INIT(ns, id) [[accumulate]] void Register_##ns##_##id##_init(entity this)
#define REGISTER_INIT_POST(ns, id) [[accumulate]] void Register_##ns##_##id##_init_post(entity this)

#define REGISTRY(id, max) \
	void Register##id() {} \
	const int id##_MAX = max; \
	noref entity _##id[id##_MAX], id##_first, id##_last; \
	int id##_COUNT; \
	entity _##id##_from(int i, entity null) { if (i >= 0 && i < id##_COUNT) { entity e = _##id[i]; if (e) return e; } return null; }

/** registered item identifier */
.string registered_id;

/**
 * Register a new entity with a global constructor.
 * Must be followed by a semicolon or a function body with a `this` parameter.
 * Wrapper macros may perform actions after user initialization like so:
 *     #define REGISTER_FOO(id) \
 *         REGISTER(RegisterFoos, FOO, FOOS, id, m_id, NEW(Foo)); \
 *         REGISTER_INIT_POST(FOO, id) { \
 *             print("Registering foo #", this.m_id + 1, "\n"); \
 *         } \
 *         REGISTER_INIT(FOO, id)
 *
 * Don't forget to forward declare `initfunc` and call `REGISTER_REGISTRY`:
 *     void RegisterFoos();
 *     REGISTER_REGISTRY(RegisterFoos)
 *
 * @param initfunc  The global constructor to accumulate into
 * @param ns        Short for namespace, prefix for each global (ns##_##id)
 * @param array     The array to add each entity to. Also requires `array##_first` and `array##_last` to be defined
 * @param id        The identifier of the current entity being registered
 * @param fld       The field to store the current count into
 * @param inst      An expression to create a new instance, invoked for every registration
 */
#define REGISTER(initfunc, ns, array, id, fld, inst) \
	entity ns##_##id; \
	REGISTER_INIT(ns, id) {} \
	REGISTER_INIT_POST(ns, id) {} \
	void Register_##ns##_##id() \
	{ \
		if (array##_COUNT >= array##_MAX) LOG_FATALF("Registry capacity exceeded (%s)", ftos(array##_MAX)); \
		entity this = inst; \
		ns##_##id = this; \
		this.registered_id = #id; \
		REGISTRY_PUSH(array, fld, this); \
		Register_##ns##_##id##_init(this); \
		Register_##ns##_##id##_init_post(this); \
	} \
	ACCUMULATE_FUNCTION(initfunc, Register_##ns##_##id) \
	REGISTER_INIT(ns, id)

#define REGISTRY_PUSH(array, fld, it) do { \
	it.fld = array##_COUNT; \
	_##array[array##_COUNT++] = it; \
	if (!array##_first) array##_first = it; \
	if (array##_last)   array##_last.REGISTRY_NEXT = it; \
	array##_last = it; \
} while (0)

#define REGISTRY_RESERVE(registry, fld, id, suffix) do { \
	entity e = new(registry_reserved); \
	e.registered_id = #id #suffix; \
	REGISTRY_PUSH(registry, fld, e); \
} while (0)

/** internal next pointer */
#define REGISTRY_NEXT enemy
.entity REGISTRY_NEXT;

#define REGISTRY_SORT(id, skip) \
	void _REGISTRY_SWAP_##id(int i, int j, entity pass) \
	{ \
		i += skip; j += skip; \
		\
		entity a = _##id[i], b = _##id[j]; \
		_##id[i] = b; \
		_##id[j] = a; \
        \
		entity a_next = a.REGISTRY_NEXT, b_next = b.REGISTRY_NEXT; \
		a.REGISTRY_NEXT = b_next; \
		b.REGISTRY_NEXT = a_next; \
        \
		if (i == 0) id##_first = b; \
		else _##id[i - 1].REGISTRY_NEXT = b; \
        \
		if (j == 0) id##_first = a; \
		else _##id[j - 1].REGISTRY_NEXT = a; \
	} \
	int _REGISTRY_CMP_##id(int i, int j, entity pass) \
	{ \
		i += skip; j += skip; \
		string a = _##id[i].registered_id; \
		string b = _##id[j].registered_id; \
		return strcmp(a, b); \
	} \
	STATIC_INIT(Registry_sort_##id) \
	{ \
		heapsort(id##_COUNT - (skip), _REGISTRY_SWAP_##id, _REGISTRY_CMP_##id, NULL); \
	}

#define REGISTRY_HASH(id) Registry_hash_##id

[[accumulate]] void Registry_check(string r, string server) { }
[[accumulate]] void Registry_send_all() { }

#ifdef SVQC
void Registry_send(string id, string hash);
#else
#define Registry_send(id, hash)
#endif

#define REGISTRY_CHECK(id) \
	string REGISTRY_HASH(id); \
	STATIC_INIT(Registry_check_##id) \
	{ \
		string algo = "SHA256"; \
		string join = ":"; \
		string s = ""; \
		FOREACH(id, true, LAMBDA(s = strcat(s, join, it.registered_id))); \
		s = substring(s, strlen(join), -1); \
		string h = REGISTRY_HASH(id) = strzone(digest_hex(algo, s)); \
		LOG_TRACEF(#id ": %s\n[%s]\n", h, s); \
	} \
	[[accumulate]] void Registry_check(string r, string sv) \
	{ \
		if (r == #id) \
		{ \
			string cl = REGISTRY_HASH(id); \
			if (cl != sv) \
			{ \
				LOG_FATALF("client/server mismatch (%s).\nCL: %s\nSV: %s\n", r, cl, sv); \
			} \
		} \
	} \
	[[accumulate]] void Registry_send_all() { Registry_send(#id, REGISTRY_HASH(id)); } \

#endif
