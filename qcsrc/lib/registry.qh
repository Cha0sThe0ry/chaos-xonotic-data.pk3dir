#ifndef REGISTRY_H
#define REGISTRY_H

#include "oo.qh"

/**
 * Declare a new registry.
 *
 * Don't forget to call `REGISTER_REGISTRY`:
 *     REGISTER_REGISTRY(Foos)
 */
#define REGISTRY(id, max) \
	void Register##id() {} \
	const int id##_MAX = max; \
	noref entity _##id[id##_MAX], id##_first, id##_last; \
	int id##_COUNT; \
	entity _##id##_from(int i, entity null) { if (i >= 0 && i < id##_COUNT) { entity e = _##id[i]; if (e) return e; } return null; }

REGISTRY(Registries, BITS(8))

/** registered item identifier */
.string registered_id;

/**
 * Register a new entity with a registry.
 * Must be followed by a semicolon or a function body with a `this` parameter.
 * Wrapper macros may perform actions after user initialization like so:
 *     #define REGISTER_FOO(id) \
 *         REGISTER(Foos, FOO, id, m_id, NEW(Foo)); \
 *         REGISTER_INIT_POST(FOO, id) { \
 *             print("Registering foo #", this.m_id + 1, "\n"); \
 *         } \
 *         REGISTER_INIT(FOO, id)
 *
 *
 * @param registry  The registry to add each entity to.
 * @param ns        Short for namespace, prefix for each global (ns##_##id)
 * @param id        The identifier of the current entity being registered
 * @param fld       The field to store the locally unique unique entity id
 * @param inst      An expression to create a new instance, invoked for every registration
 */
#define REGISTER(registry, ns, id, fld, inst) \
	entity ns##_##id; \
	REGISTER_INIT(ns, id) {} \
	REGISTER_INIT_POST(ns, id) {} \
	void Register_##ns##_##id() \
	{ \
		if (registry##_COUNT >= registry##_MAX) LOG_FATALF("Registry capacity exceeded (%s)", ftos(registry##_MAX)); \
		entity this = ns##_##id = inst; \
		this.registered_id = #id; \
		this.fld = registry##_COUNT; \
		_##registry[registry##_COUNT] = this; \
		++registry##_COUNT; \
		if (!registry##_first) registry##_first = this; \
		if (registry##_last)   registry##_last.REGISTRY_NEXT = this; \
		registry##_last = this; \
		Register_##ns##_##id##_init(this); \
		Register_##ns##_##id##_init_post(this); \
	} \
	ACCUMULATE_FUNCTION(Register##registry, Register_##ns##_##id) \
	REGISTER_INIT(ns, id)

#define REGISTER_INIT(ns, id) [[accumulate]] void Register_##ns##_##id##_init(entity this)
#define REGISTER_INIT_POST(ns, id) [[accumulate]] void Register_##ns##_##id##_init_post(entity this)

/** internal next pointer */
#define REGISTRY_NEXT enemy
.entity REGISTRY_NEXT;

#define REGISTRY_SORT(id, skip) \
	void _REGISTRY_SWAP_##id(int i, int j, entity pass) \
	{ \
		i += skip; j += skip; \
		\
		entity a = _##id[i], b = _##id[j]; \
		_##id[i] = b; \
		_##id[j] = a; \
        \
		entity a_next = a.REGISTRY_NEXT, b_next = b.REGISTRY_NEXT; \
		a.REGISTRY_NEXT = b_next; \
		b.REGISTRY_NEXT = a_next; \
        \
		if (i == 0) id##_first = b; \
		else _##id[i - 1].REGISTRY_NEXT = b; \
        \
		if (j == 0) id##_first = a; \
		else _##id[j - 1].REGISTRY_NEXT = a; \
	} \
	int _REGISTRY_CMP_##id(int i, int j, entity pass) \
	{ \
		i += skip; j += skip; \
		string a = _##id[i].registered_id; \
		string b = _##id[j].registered_id; \
		return strcmp(a, b); \
	} \
	STATIC_INIT(Registry_sort_##id) \
	{ \
		heapsort(id##_COUNT - (skip), _REGISTRY_SWAP_##id, _REGISTRY_CMP_##id, NULL); \
	}

#define REGISTRY_HASH(id) Registry_hash_##id

[[accumulate]] void Registry_check(string r, string server) { }
[[accumulate]] void Registry_send_all() { }

#ifdef SVQC
void Registry_send(string id, string hash);
#else
#define Registry_send(id, hash)
#endif

#define REGISTRY_CHECK(id) \
	string REGISTRY_HASH(id); \
	STATIC_INIT(Registry_check_##id) \
	{ \
		string algo = "SHA256"; \
		string join = ":"; \
		string s = ""; \
		FOREACH(id, true, LAMBDA(s = strcat(s, join, it.registered_id))); \
		s = substring(s, strlen(join), -1); \
		string h = REGISTRY_HASH(id) = strzone(digest_hex(algo, s)); \
		LOG_TRACEF(#id ": %s\n[%s]\n", h, s); \
	} \
	void Registry_check(string r, string sv) \
	{ \
		if (r == #id) \
		{ \
			string cl = REGISTRY_HASH(id); \
			if (cl != sv) \
			{ \
				LOG_FATALF("client/server mismatch (%s).\nCL: %s\nSV: %s\n", r, cl, sv); \
			} \
		} \
	} \
	void Registry_send_all() { Registry_send(#id, REGISTRY_HASH(id)); } \

#define REGISTER_REGISTRY(...) EVAL(OVERLOAD(REGISTER_REGISTRY, __VA_ARGS__))
#define REGISTER_REGISTRY_1(id) REGISTER_REGISTRY_2(id, #id)
#define REGISTER_REGISTRY_2(id, str) \
	ACCUMULATE_FUNCTION(__static_init, Register##id) \
	CLASS(id##Registry, Object) \
		ATTRIB(id##Registry, m_name, string, str) \
		ATTRIB(id##Registry, REGISTRY_NEXT, entity, id##_first) \
	ENDCLASS(id##Registry) \
	REGISTER(Registries, REGISTRY, id, m_id, NEW(id##Registry));


#endif
