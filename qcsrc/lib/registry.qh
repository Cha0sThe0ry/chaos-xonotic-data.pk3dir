#ifndef REGISTRY_H
#define REGISTRY_H

#include "oo.qh"

#define REGISTER_INIT(ns, id) [[accumulate]] void Register_##ns##_##id##_init(entity this)
#define REGISTER_INIT_POST(ns, id) [[accumulate]] void Register_##ns##_##id##_init_post(entity this)

#define REGISTRY(id, max) \
	void Register##id() {} \
	const int id##_MAX = max; \
	noref entity _##id[id##_MAX], id##_first, id##_last; \
	int id##_COUNT; \
	entity _##id##_from(int i, entity null) { if (i >= 0 && i < id##_COUNT) { entity e = _##id[i]; if (e) return e; } return null; }

/**
 * Register a new entity with a global constructor.
 * Must be followed by a semicolon or a function body with a `this` parameter.
 * Wrapper macros may perform actions after user initialization like so:
 *     #define REGISTER_FOO(id) \
 *         REGISTER(RegisterFoos, FOO, FOOS, id, m_id, NEW(Foo)); \
 *         REGISTER_INIT_POST(FOO, id) { \
 *             print("Registering foo #", this.m_id + 1, "\n"); \
 *         } \
 *         REGISTER_INIT(FOO, id)
 *
 * Don't forget to forward declare `initfunc` and call `REGISTER_REGISTRY`:
 *     void RegisterFoos();
 *     REGISTER_REGISTRY(RegisterFoos)
 *
 * @param initfunc  The global constructor to accumulate into
 * @param ns        Short for namespace, prefix for each global (ns##_##id)
 * @param array     The array to add each entity to. Also requires `array##_first` and `array##_last` to be defined
 * @param id        The identifier of the current entity being registered
 * @param fld       The field to store the current count into
 * @param inst      An expression to create a new instance, invoked for every registration
 */
#define REGISTER(initfunc, ns, array, id, fld, inst)                \
	entity ns##_##id;                                               \
	REGISTER_INIT(ns, id) {}                                       \
	REGISTER_INIT_POST(ns, id) {}                                  \
	void Register_##ns##_##id() \
	{                                   \
		if (array##_COUNT >= array##_MAX) LOG_FATALF("Registry capacity exceeded (%s)", ftos(array##_MAX)); \
		entity this = inst;                                         \
		ns##_##id = this;                                           \
		this.fld = array##_COUNT;                                   \
		_##array[array##_COUNT++] = this;                           \
		if (!array##_first)    array##_first = this;                \
		if (array##_last)     array##_last.REGISTRY_NEXT = this;    \
		array##_last = this;                                        \
		Register_##ns##_##id##_init(this);                          \
		Register_##ns##_##id##_init_post(this);                     \
	}                                                               \
	ACCUMULATE_FUNCTION(initfunc, Register_##ns##_##id)             \
	REGISTER_INIT(ns, id)

/** internal next pointer */
#define REGISTRY_NEXT enemy
.entity REGISTRY_NEXT;

#define REGISTRY_SORT(id, field, skip)                              \
	void _REGISTRY_SWAP_##id(int i, int j, entity pass) \
	{           \
		i += skip; j += skip;                                       \
                                                                    \
		entity a = _##id[i], b = _##id[j];                          \
		_##id[i] = b;                                               \
		_##id[j] = a;                                               \
                                                                    \
		entity a_next = a.REGISTRY_NEXT, b_next = b.REGISTRY_NEXT;  \
		a.REGISTRY_NEXT = b_next;                                   \
		b.REGISTRY_NEXT = a_next;                                   \
                                                                    \
		if (i == 0) id##_first = b;                                 \
		else _##id[i - 1].REGISTRY_NEXT = b;                        \
                                                                    \
		if (j == 0) id##_first = a;                                 \
		else _##id[j - 1].REGISTRY_NEXT = a;                        \
	}                                                               \
	float _REGISTRY_CMP_##id(int i, int j, entity pass) \
	{           \
		i += skip; j += skip;                                       \
		string a = _##id[i].field;                                  \
		string b = _##id[j].field;                                  \
		return strcasecmp(a, b);                                    \
	}                                                               \
	STATIC_INIT(Registry_sort_##id) \
	{                               \
		heapsort(id##_COUNT - (skip), _REGISTRY_SWAP_##id, _REGISTRY_CMP_##id, NULL); \
	}

#endif
