#ifndef VECTOR_H
#define VECTOR_H

const vector eX = '1 0 0';
const vector eY = '0 1 0';
const vector eZ = '0 0 1';

vector randompos(vector m1, vector m2)
{
	vector v;
	m2 = m2 - m1;
	v_x = m2_x * random() + m1_x;
	v_y = m2_y * random() + m1_y;
	v_z = m2_z * random() + m1_z;
	return v;
}

float vlen2d(vector v)
{
	return sqrt(v.x * v.x + v.y * v.y);
}

float vlen_maxnorm2d(vector v)
{
	return max(v.x, v.y, -v.x, -v.y);
}

float vlen_minnorm2d(vector v)
{
	return min(max(v.x, -v.x), max(v.y, -v.y));
}

float dist_point_line(vector p, vector l0, vector ldir)
{
	ldir = normalize(ldir);

	// remove the component in line direction
	p = p - (p * ldir) * ldir;

	// vlen of the remaining vector
	return vlen(p);
}

/** requires that m2>m1 in all coordinates, and that m4>m3 */
float boxesoverlap(vector m1, vector m2, vector m3, vector m4) { return m2_x >= m3_x && m1_x <= m4_x && m2_y >= m3_y && m1_y <= m4_y && m2_z >= m3_z && m1_z <= m4_z; }

/** requires the same as boxesoverlap, but is a stronger condition */
float boxinsidebox(vector smins, vector smaxs, vector bmins, vector bmaxs) { return smins.x >= bmins.x && smaxs.x <= bmaxs.x && smins.y >= bmins.y && smaxs.y <= bmaxs.y && smins.z >= bmins.z && smaxs.z <= bmaxs.z; }


vector vec2(vector v)
{
	v.z = 0;
	return v;
}

vector vec3(float x, float y, float z)
{
	vector v;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}

vector rotate(vector v, float a)
{
	float a_sin = sin(a), a_cos = cos(a);
	vector r = '0 0 0';
	r.x =      v.x * a_cos + v.y * a_sin;
	r.y = -1 * v.x * a_sin + v.y * a_cos;
	return r;
}

vector yinvert(vector v)
{
	v.y = 1 - v.y;
	return v;
}

#ifndef MENUQC
	vector get_corner_position(entity box, int corner)
	{
		switch (corner)
		{
			case 1: return vec3(box.absmin.x, box.absmin.y, box.absmin.z);
			case 2: return vec3(box.absmax.x, box.absmin.y, box.absmin.z);
			case 3: return vec3(box.absmin.x, box.absmax.y, box.absmin.z);
			case 4: return vec3(box.absmin.x, box.absmin.y, box.absmax.z);
			case 5: return vec3(box.absmax.x, box.absmax.y, box.absmin.z);
			case 6: return vec3(box.absmin.x, box.absmax.y, box.absmax.z);
			case 7: return vec3(box.absmax.x, box.absmin.y, box.absmax.z);
			case 8: return vec3(box.absmax.x, box.absmax.y, box.absmax.z);
			default: return '0 0 0';
		}
	}

	vector NearestPointOnBox(entity box, vector org)
	{
		vector m1 = box.mins + box.origin;
		vector m2 = box.maxs + box.origin;

		vector ret;
		ret.x = bound(m1.x, org.x, m2.x);
		ret.y = bound(m1.y, org.y, m2.y);
		ret.z = bound(m1.z, org.z, m2.z);
		return ret;
	}
#endif

#endif
