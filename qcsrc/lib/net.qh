#ifndef NET_H
#define NET_H

#ifdef SVQC
	.int Version;  // deprecated, use SendFlags
	.int SendFlags;
	.bool(entity to, int sendflags)SendEntity;
	.bool(entity this, entity to, int sendflags)SendEntity3;

	bool SendEntity_self(entity to, int sendflags) { return self.SendEntity3(self, to, sendflags); }

	void Net_LinkEntity(entity e, bool docull, float dt, bool(entity this, entity to, int sendflags)sendfunc)
	{
		if (e.classname == "") e.classname = "net_linked";

		if (e.model == "" || self.modelindex == 0)
		{
			vector mi = e.mins;
			vector ma = e.maxs;
			_setmodel(e, "null");
			setsize(e, mi, ma);
		}

		e.SendEntity = SendEntity_self;
		e.SendEntity3 = sendfunc;
		e.SendFlags = 0xFFFFFF;

		if (!docull) e.effects |= EF_NODEPTHTEST;

		if (dt)
		{
			e.nextthink = time + dt;
			e.think = SUB_Remove;
		}
	}

	.void() uncustomizeentityforclient;
	.float uncustomizeentityforclient_set;

	void SetCustomizer(entity e, float(void)customizer, void(void)uncustomizer)
	{
		e.customizeentityforclient = customizer;
		e.uncustomizeentityforclient = uncustomizer;
		e.uncustomizeentityforclient_set = !!uncustomizer;
	}

	void UncustomizeEntitiesRun()
	{
		for (entity e = NULL; (e = findfloat(e, uncustomizeentityforclient_set, 1)); )
			WITH(entity, self, e, e.uncustomizeentityforclient());
	}

#endif

#include "registry.qh"
#include "sort.qh"

.string netname;
.int m_id;
.bool(entity this, bool isNew) m_read;

#ifdef CSQC
	#define Net_Accept(classname) \
		do \
		{ \
			if (!this)    this = new(classname); \
		} \
		while (0)
	#define Net_Reject() \
		do \
		{ \
			if (this)     remove(this); \
		} \
		while (0)
	#define NET_HANDLE(id, param) \
		bool Net_Handle_##id(entity this, param)
#else
	#define WriteHeader(to, id) \
		do \
		{ \
			if (NET_##id##_istemp) WriteByte(to, SVC_TEMPENTITY); \
			WriteByte(to, NET_##id.m_id); \
		} \
		while (0)
#endif

#ifdef CSQC
	#define REGISTER_NET_LINKED(id) \
		[[accumulate]] NET_HANDLE(id, bool) \
		{ \
			this = self; \
			this.sourceLocFile = __FILE__; \
			this.sourceLocLine = __LINE__; \
		} \
		REGISTER(RegisterLinkedEntities, NET, LinkedEntities, id, m_id, new(net_linked_packet)) \
		{ \
			make_pure(this); \
			this.netname = #id; \
			this.m_read = Net_Handle_##id; \
		}
#else
	#define REGISTER_NET_LINKED(id) \
		const bool NET_##id##_istemp = false; \
		REGISTER(RegisterLinkedEntities, NET, LinkedEntities, id, m_id, new(net_linked_packet)) \
		{ \
			make_pure(this); \
			this.netname = #id; \
		}
#endif

REGISTRY(LinkedEntities, BITS(8) - 1)
#define LinkedEntities_from(i) _LinkedEntities_from(i, NULL)
REGISTER_REGISTRY(RegisterLinkedEntities)
REGISTRY_SORT(LinkedEntities, netname, 0)
STATIC_INIT(RegisterLinkedEntities_renumber)
{
	for (int i = 0; i < LinkedEntities_COUNT; ++i)
		LinkedEntities_from(i).m_id = 1 + i;
}

#ifdef CSQC
	#define REGISTER_NET_TEMP(id) \
		NET_HANDLE(id, bool); \
		REGISTER(RegisterTempEntities, NET, TempEntities, id, m_id, new(net_temp_packet)) \
		{ \
			make_pure(this); \
			this.netname = #id; \
			this.m_read = Net_Handle_##id; \
		}
#else
	#define REGISTER_NET_TEMP(id) \
		const bool NET_##id##_istemp = true; \
		REGISTER(RegisterTempEntities, NET, TempEntities, id, m_id, new(net_temp_packet)) \
		{ \
			make_pure(this); \
			this.netname = #id; \
		}
#endif

REGISTRY(TempEntities, BITS(8) - 80)
#define TempEntities_from(i) _TempEntities_from(i, NULL)
REGISTER_REGISTRY(RegisterTempEntities)
REGISTRY_SORT(TempEntities, netname, 0)
STATIC_INIT(RegisterTempEntities_renumber)
{
	for (int i = 0; i < TempEntities_COUNT; ++i)
		TempEntities_from(i).m_id = 80 + i;
}

#ifndef MENUQC
	#ifdef CSQC
		int ReadInt24_t()
		{
			int v = ReadShort() << 8; // note: this is signed
			v += ReadByte();          // note: this is unsigned
			return v;
		}
		vector ReadInt48_t()
		{
			vector v;
			v.x = ReadInt24_t();
			v.y = ReadInt24_t();
			v.z = 0;
			return v;
		}
		vector ReadInt72_t()
		{
			vector v;
			v.x = ReadInt24_t();
			v.y = ReadInt24_t();
			v.z = ReadInt24_t();
			return v;
		}
	#else
		const int MSG_ENTITY = 5;

		void WriteInt24_t(float dst, float val)
		{
			float v;
			WriteShort(dst, (v = floor(val >> 8)));
			WriteByte(dst, val - (v << 8));  // 0..255
		}
		void WriteInt48_t(float dst, vector val)
		{
			WriteInt24_t(dst, val.x);
			WriteInt24_t(dst, val.y);
		}
		void WriteInt72_t(float dst, vector val)
		{
			WriteInt24_t(dst, val.x);
			WriteInt24_t(dst, val.y);
			WriteInt24_t(dst, val.z);
		}

		// allow writing to also pass through to spectators (like so spectators see the same centerprints as players for example)
        #define WRITESPECTATABLE_MSG_ONE_VARNAME(varname,statement) entity varname; varname = msg_entity; FOR_EACH_REALCLIENT(msg_entity) if(msg_entity == varname || (msg_entity.classname == STR_SPECTATOR && msg_entity.enemy == varname)) statement msg_entity = varname
        #define WRITESPECTATABLE_MSG_ONE(statement) WRITESPECTATABLE_MSG_ONE_VARNAME(oldmsg_entity, statement)
        #define WRITESPECTATABLE(msg,statement) if(msg == MSG_ONE) { WRITESPECTATABLE_MSG_ONE(statement); } else statement float WRITESPECTATABLE_workaround = 0
	#endif
#endif

#endif
