#pragma once

CLASS(Client, Object)
    /** Client name */
    ATTRIB(Client, netname, string, this.netname)
    ATTRIB(Client, colormap, int, this.colormap)
    ATTRIB(Client, team, int, this.team)
    ATTRIB(Client, clientcolors, int, this.clientcolors)
    /** Client IP */
    ATTRIB(Client, netaddress, string, this.netaddress)
    ATTRIB(Client, playermodel, string, this.playermodel)
    ATTRIB(Client, playerskin, int, this.playerskin)

    /** fingerprint of CA key the player used to authenticate */
    ATTRIB(Client, crypto_keyfp, string, this.crypto_keyfp)
    /** fingerprint of CA key the server used to authenticate to the player */
    ATTRIB(Client, crypto_mykeyfp, string, this.crypto_mykeyfp)
    /** fingerprint of ID used by the player entity, or string_null if not identified */
    ATTRIB(Client, crypto_idfp, string, this.crypto_idfp)
    /** set if the player's ID has been signed */
    ATTRIB(Client, crypto_idfp_signed, bool, this.crypto_idfp_signed)
    /** the string "AES128" if encrypting, and string_null if plaintext */
    ATTRIB(Client, crypto_encryptmethod, string, this.crypto_encryptmethod)
    /** the string "HMAC-SHA256" if signing, and string_null if plaintext */
    ATTRIB(Client, crypto_signmethod, string, this.crypto_signmethod)
    INIT(Client) {
        this.flags = FL_CLIENT;
    }
ENDCLASS(Client)

float c1, c2, c3, c4;

void play_countdown(float finished, Sound samp);

float CalcRotRegen(float current, float regenstable, float regenfactor, float regenlinear, float regenframetime, float rotstable, float rotfactor, float rotlinear, float rotframetime, float limit);

float Spectate(entity pl);

#define SPECTATE_COPY() [[accumulate]] void SpectateCopy(entity this, entity spectatee)
#define SPECTATE_COPYFIELD(fld) SPECTATE_COPY() { this.(fld) = spectatee.(fld); }
