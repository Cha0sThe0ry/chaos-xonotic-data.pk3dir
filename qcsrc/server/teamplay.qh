#pragma once

string cache_mutatormsg;
string cache_lastmutatormsg;

/// \brief Returns the global team entity at the given index.
/// \param[in] index Index of the team.
/// \return Global team entity at the given index.
entity Team_GetTeamFromIndex(int index);

/// \brief Returns the global team entity that corresponds to the given TEAM_NUM
/// value.
/// \param[in] team_num Team value. See TEAM_NUM constants.
/// \return Global team entity that corresponds to the given TEAM_NUM value.
entity Team_GetTeam(int team_num);

/// \brief Returns the score of the team.
/// \param[in] team_ Team entity.
/// \return Score of the team.
float Team_GetTeamScore(entity team_);

/// \brief Sets the score of the team.
/// \param[in,out] team_ Team entity.
/// \param[in] score Score to set.
void Team_SetTeamScore(entity team_, float score);

/// \brief Checks whether the player can join teams according to global
/// configuration and mutator settings.
/// \param[in] for_whom Player to check for. Pass NULL for global rules.
/// \note This function sets various internal variables and is required to be
/// called before several other functions.
void CheckAllowedTeams(entity for_whom);

/// \brief Returns the bitmask of allowed teams.
/// \return Bitmask of allowed teams.
/// \note You need to call CheckAllowedTeams before calling this function.
int GetAllowedTeams();

/// \brief Returns whether the team is allowed.
/// \param[in] team_ Team entity.
/// \return True if team is allowed, false otherwise.
/// \note You need to call CheckAllowedTeams before calling this function.
bool Team_IsAllowed(entity team_);

/// \brief Counts the number of players and various other information about
/// each team.
/// \param[in] ignore Player to ignore. This is useful if you plan to switch the
/// player's team. Pass NULL for global information.
/// \note You need to call CheckAllowedTeams before calling this function.
/// \note This function sets many internal variables and is required to be
/// called before several other functions.
void GetTeamCounts(entity ignore);

/// \brief Returns the number of players (both humans and bots) in a team.
/// \param[in] team_ Team entity.
/// \return Number of player (both humans and bots) in a team.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
int Team_GetNumberOfPlayers(entity team_);

/// \brief Returns the number of bots in a team.
/// \param[in] team_ Team entity.
/// \return Number of bots in a team.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
int Team_GetNumberOfBots(entity team_);

/// \brief Returns the human with the lowest score in a team or NULL if there is
/// none.
/// \param[in] team_ Team entity.
/// \return Human with the lowest score in a team or NULL if there is none.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
entity Team_GetLowestHuman(entity team_);

/// \brief Returns the bot with the lowest score in a team or NULL if there is
/// none.
/// \param[in] team_ Team entity.
/// \return Bot with the lowest score in a team or NULL if there is none.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
entity Team_GetLowestBot(entity team_);

int redowned, blueowned, yellowowned, pinkowned;

void TeamchangeFrags(entity e);

void LogTeamchange(float player_id, float team_number, float type);

void default_delayedinit(entity this);

void InitGameplayMode();

string GetClientVersionMessage(entity this);

string getwelcomemessage(entity this);

void setcolor(entity this, int clr);

void SetPlayerColors(entity player, float _color);

/// \brief Kills player as a result of team change.
/// \param[in,out] player Player to kill.
void KillPlayerForTeamChange(entity player);

/// \brief Sets the team of the player.
/// \param[in,out] player Player to adjust.
/// \param[in] team_num Team number to set. See TEAM_NUM constants.
/// \return True if team switch was successful, false otherwise.
bool SetPlayerTeamSimple(entity player, int team_num);

/// \brief Sets the team of the player.
/// \param[in,out] player Player to adjust.
/// \param[in] destination_team_index Index of the team to set.
/// \param[in] source_team_index Previous index of the team of the player.
/// \param[in] no_print Whether to print this event to players' console.
/// \return True if team switch was successful, false otherwise.
bool SetPlayerTeam(entity player, int destination_team_index,
	int source_team_index, bool no_print);

/// \brief Returns whether one team is smaller than the other.
/// \param[in] team_index_a Index of the first team.
/// \param[in] team_index_b Index of the second team.
/// \param[in] player Player to check.
/// \param[in] use_score Whether to take into account team scores.
/// \return True if first team is smaller than the second one, false otherwise.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
bool IsTeamSmallerThanTeam(int team_index_a, int team_index_b, entity player,
	bool use_score);

/// \brief Returns whether one team is equal to the other.
/// \param[in] team_index_a Index of the first team.
/// \param[in] team_index_b Index of the second team.
/// \param[in] player Player to check.
/// \param[in] use_score Whether to take into account team scores.
/// \return True if first team is equal to the second one, false otherwise.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
bool IsTeamEqualToTeam(int team_index_a, int team_index_b, entity player,
	bool use_score);

/// \brief Returns the bitmask of the best teams for the player to join.
/// \param[in] player Player to check.
/// \param[in] use_score Whether to take into account team scores.
/// \return Bitmask of the best teams for the player to join.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
int FindBestTeams(entity player, bool use_score);

/// \brief Finds the best team for the player.
/// \param[in] player Player to check.
/// \param[in] ignore_player ???
/// \return Index of the best team for the player. If there are several equally
/// good teams available, the function will pick a random one.
int FindBestTeam(entity player, float ignore_player);

void JoinBestTeam(entity this, bool force_best_team);

/// \brief Auto balances bots in teams after the player has changed team.
/// \param[in] source_team_index Previous index of the team of the player.
/// \param[in] destination_team_index Current index of the team of the player.
/// \note You need to call CheckAllowedTeams and GetTeamCounts before calling
/// this function.
void AutoBalanceBots(int source_team_index, int destination_team_index);
