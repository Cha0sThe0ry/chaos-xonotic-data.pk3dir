#pragma once

string cache_mutatormsg;
string cache_lastmutatormsg;

// client counts for each team
//float c1, c2, c3, c4;
// # of bots on those teams
float numbotsteam1;
float numbotsteam2;
float numbotsteam3;
float numbotsteam4;
entity lowestplayerteam1;
entity lowestplayerteam2;
entity lowestplayerteam3;
entity lowestplayerteam4;
entity lowestbotteam1;
entity lowestbotteam2;
entity lowestbotteam3;
entity lowestbotteam4;

int redowned, blueowned, yellowowned, pinkowned;

//float audit_teams_time;

void TeamchangeFrags(entity e);

void LogTeamchange(float player_id, float team_number, float type);

void default_delayedinit(entity this);

void ActivateTeamplay();

void InitGameplayMode();

string GetClientVersionMessage(entity this);

string getwelcomemessage(entity this);

void SetPlayerColors(entity player, float _color);

/// \brief Sets the team of the player.
/// \param[in,out] player Player to adjust.
/// \param[in] teamnum Team number to set. See TEAM_NUM constants.
/// \return True if team switch was successful, false otherwise.
bool SetPlayerTeamSimple(entity player, int teamnum);

/// \brief Sets the team of the player.
/// \param[in,out] player Player to adjust.
/// \param[in] destinationteam Team to set.
/// \param[in] sourceteam Previous team of the player.
/// \param[in] noprint Whether to print this event to players' console.
/// \return No return.
void SetPlayerTeam(entity player, int destinationteam, int sourceteam, bool noprint);

// set c1...c4 to show what teams are allowed
void CheckAllowedTeams (entity for_whom);

float PlayerValue(entity p);

// c1...c4 should be set to -1 (not allowed) or 0 (allowed).
// teams that are allowed will now have their player counts stored in c1...c4
void GetTeamCounts(entity ignore);

/// \brief Returns whether one team is smaller than the other.
/// \param[in] teama First team.
/// \param[in] teamb Second team.
/// \param[in] e Player to check.
/// \param[in] usescore Whether to take into account team scores.
/// \return True if first team is smaller than the second one, false otherwise.
/// \note This function assumes that CheckAllowedTeams and GetTeamCounts have
/// been called.
bool IsTeamSmallerThanTeam(int teama, int teamb, entity e, bool usescore);

/// \brief Returns whether one team is equal to the other.
/// \param[in] teama First team.
/// \param[in] teamb Second team.
/// \param[in] e Player to check.
/// \param[in] usescore Whether to take into account team scores.
/// \return True if first team is equal to the second one, false otherwise.
/// \note This function assumes that CheckAllowedTeams and GetTeamCounts have
/// been called.
bool IsTeamEqualToTeam(int teama, int teamb, entity e, bool usescore);

/// \brief Returns the bitmask of the best teams for the player to join.
/// \param[in] player Player to check.
/// \param[in] usescore Whether to take into account team scores.
/// \return Bitmask of the best teams for the player to join.
/// \note This function assumes that CheckAllowedTeams and GetTeamCounts have
/// been called.
int FindBestTeams(entity player, bool usescore);

// returns # of smallest team (1, 2, 3, 4)
// NOTE: Assumes CheckAllowedTeams has already been called!
float FindSmallestTeam(entity player, float ignore_player);

int JoinBestTeam(entity this, bool only_return_best, bool forcebestteam);

/// \brief Auto balances bots in teams after the player has changed team.
/// \param[in] sourceteam Previous team of the player (1, 2, 3, 4).
/// \param[in] destinationteam Current team of the player (1, 2, 3, 4).
/// \return No return.
/// \note This function assumes that CheckAllowedTeams and GetTeamCounts have
/// been called.
void AutoBalanceBots(int sourceteam, int destinationteam);

void ShufflePlayerOutOfTeam (float source_team);

void setcolor(entity this, int clr);
