#pragma once

#include "../gamemode.qh"

#define autocvar_g_invasion_point_limit cvar("g_invasion_point_limit")
int autocvar_g_invasion_teams;
int autocvar_g_invasion_type;
bool autocvar_g_invasion_team_spawns;
bool g_invasion;
void invasion_Initialize();

REGISTER_MUTATOR(inv, false)
{
	MUTATOR_ONADD
	{
		if (time > 1) // game loads at time 1
			error("This is a game type and it cannot be added at runtime.");
		g_invasion = true;
		invasion_Initialize();

		cvar_settemp("g_monsters", "1");

        GameRules_limit_score(autocvar_g_invasion_point_limit);

		if (autocvar_g_invasion_teams >= 2)
		{
			GameRules_teams(true);
			GameRules_spawning_teams(autocvar_g_invasion_team_spawns);
		}
	}

	MUTATOR_ONROLLBACK_OR_REMOVE
	{
		// we actually cannot roll back invasion_Initialize here
		// BUT: we don't need to! If this gets called, adding always
		// succeeds.
	}

	MUTATOR_ONREMOVE
	{
		LOG_INFO("This is a game type and it cannot be removed at runtime.");
		return -1;
	}

	return 0;
}

float inv_numspawned;
float inv_maxspawned;
float inv_roundcnt;
float inv_maxrounds;
float inv_numkilled;
float inv_lastcheck;
float inv_maxcurrent;

float invasion_teams;
float inv_monsters_perteam[17];

float inv_monsterskill;

const float ST_INV_KILLS = 1;

const int INV_TYPE_ROUND = 0; // round-based waves of enemies
const int INV_TYPE_HUNT = 1; // clear the map of placed enemies
const int INV_TYPE_STAGE = 2; // reach the end of the level
